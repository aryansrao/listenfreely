<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ListenFreely</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Geist:wght@400;500;600&family=Dancing+Script:wght@700&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Globally remove mobile tap highlight and default focus rings while keeping keyboard focus visible */
        html, body, button, a, input, textarea, select, label, .icon-btn, .control-button, .overlay-btn, .nav-item, .bento-tile, .track-card, .like-btn, .btn {
            -webkit-tap-highlight-color: transparent;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        /* Remove outlines from programmatic focus but preserve for keyboard users via :focus-visible */
        *:focus { outline: none !important; box-shadow: none !important; }
        :focus-visible { outline: 2px solid rgba(255,255,255,0.12); outline-offset: 2px; }

        /* Avoid default active background flashes */
        a:active, button:active, .icon-btn:active, .overlay-btn:active { background-color: transparent !important; }

        body {
            font-family: 'Geist', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000;
            color: #fafafa;
            min-height: 100vh;
        }

        .app {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 280px;
            background: #000;
            border-right: 1px solid #1a1a1a;
            padding: 24px;
            display: flex;
            flex-direction: column;
        }

        .logo {
            font-family: 'Dancing Script', cursive;
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 40px;
            color: #fafafa;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            color: #888;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            margin-bottom: 4px;
            font-size: 14px;
            font-weight: 500;
        }

        .nav-item:hover {
            color: #fafafa;
            background: #0a0a0a;
        }

        .nav-item.active {
            color: #fafafa;
            background: #0f0f0f;
        }

        .nav-item svg {
            width: 20px;
            height: 20px;
        }

        .main {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            padding-bottom: 120px;
        }

        .search-bar {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 24px;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 32px;
            max-width: 500px;
        }

        .search-bar svg {
            width: 18px;
            height: 18px;
            color: #666;
        }

        .search-input {
            background: none;
            border: none;
            color: #fafafa;
            font-family: 'Geist', sans-serif;
            font-size: 14px;
            flex: 1;
            outline: none;
        }

        .search-input::placeholder {
            color: #666;
        }

        /* Fix Chrome autofill / suggestion white background for the search input */
        .search-input:-webkit-autofill,
        .search-input:-webkit-autofill:focus,
        .search-input:-webkit-autofill:hover,
        #searchInput:-webkit-autofill,
        #searchInput:-webkit-autofill:focus,
        #searchInput:-webkit-autofill:hover {
            -webkit-text-fill-color: #fafafa !important;
            caret-color: #fafafa !important;
            box-shadow: 0 0 0px 1000px #0a0a0a inset !important;
            background-clip: content-box;
            transition: background-color 5000s ease-in-out 0s;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .tracks-grid {
            display: grid;
            gap: 8px;
        }

        .track-card {
            background: #0a0a0a;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .track-card:hover {
            background: #0f0f0f;
            border-color: #1a1a1a;
        }

        .track-cover {
            width: 56px;
            height: 56px;
            border-radius: 4px;
            background: #1a1a1a;
            object-fit: cover;
            flex-shrink: 0;
        }

        .track-details {
            flex: 1;
            min-width: 0;
        }

        .track-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-subtitle {
            font-size: 13px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Ensure all track lists (search, recent, liked) fit the container and don't cause horizontal overflow
           This mirrors the recent-items layout and forces truncation for long titles */
        .tracks-grid {
            width: 100%;
            box-sizing: border-box;
            padding: 0;
            display: grid;
            gap: 8px;
        }

        .tracks-grid .track-card {
            width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .tracks-grid .track-details {
            flex: 1 1 auto;
            min-width: 0;
            overflow: hidden;
        }

        /* Keep action buttons from growing and forcing overflow */
        .tracks-grid .track-actions {
            flex: 0 0 auto;
            display: flex;
            gap: 8px;
        }

        .tracks-grid .track-cover {
            flex-shrink: 0;
        }

        .track-actions {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 6px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            color: #fafafa;
            background: #1a1a1a;
        }

        .icon-btn.active {
            color: #fafafa;
        }

        .icon-btn svg {
            width: 18px;
            height: 18px;
        }

        .player-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #0a0a0a;
            border-top: 1px solid #1a1a1a;
            padding: 16px 24px;
        }

        .player-bar.hidden { display: none !important; }

        .player-content {
            display: flex;
            align-items: center;
            gap: 16px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .player-track {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 280px;
        }

        .player-cover {
            width: 48px;
            height: 48px;
            border-radius: 4px;
            background: #1a1a1a;
            object-fit: cover;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .player-cover.placeholder {
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
        }

        .player-cover.placeholder svg {
            width: 24px;
            height: 24px;
            color: #666;
        }

        .player-info {
            flex: 1;
            min-width: 0;
        }

        .player-title {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-artist {
            font-size: 12px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .source-badge {
            display: inline-block;
            background: #1a1a1a;
            color: #888;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 6px;
            text-transform: uppercase;
            font-weight: 500;
        }

        .api-section {
            margin-bottom: 32px;
        }

        .api-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #1a1a1a;
        }

        .api-name {
            font-size: 14px;
            font-weight: 600;
            color: #fafafa;
        }

        .api-count {
            font-size: 12px;
            color: #666;
        }

        .player-controls {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .controls-buttons {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-button {
            background: none;
            border: none;
            color: #fafafa;
            cursor: pointer;
            padding: 6px;
            transition: all 0.2s;
        }

        .control-button:hover {
            transform: scale(1.1);
        }

        .control-button svg {
            width: 20px;
            height: 20px;
        }

        .control-button.play-btn svg {
            width: 16px;
            height: 16px;
        }

        .control-button.play-btn {
            background: #fafafa;
            color: #000;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-button.play-btn:hover {
            background: #fff;
            transform: scale(1.05);
        }

        .progress-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            max-width: 500px;
        }

        .time-label {
            font-size: 11px;
            color: #666;
            min-width: 36px;
            text-align: center;
        }

        .progress-track {
            flex: 1;
            height: 4px;
            background: #1a1a1a;
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: #fafafa;
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s;
        }

        .player-extra {
            width: 280px;
            display: flex;
            justify-content: flex-end;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.3;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
        }

        .modal-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            font-size: 13px;
            color: #888;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            background: #000;
            border: 1px solid #1a1a1a;
            color: #fafafa;
            padding: 10px 12px;
            border-radius: 6px;
            font-family: 'Geist', sans-serif;
            font-size: 14px;
        }

        .form-input:focus {
            outline: none;
            border-color: #333;
        }

        .modal-buttons {
            display: flex;
            gap: 8px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            border-radius: 6px;
            border: none;
            font-family: 'Geist', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #fafafa;
            color: #000;
        }

        .btn-primary:hover {
            background: #fff;
        }

        .btn-secondary {
            background: #1a1a1a;
            color: #fafafa;
        }

        .btn-secondary:hover {
            background: #2a2a2a;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 13px;
        }

        .btn-danger {
            background: #3a1a1a;
            color: #ff6b6b;
            border: 1px solid #5a2a2a;
        }

        .btn-danger:hover {
            background: #4a2a2a;
            border-color: #7a3a3a;
        }

        .blend-container {
            max-width: 900px;
        }

        .blend-top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            margin-bottom: 24px;
        }

        .blend-info {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .blend-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .blend-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .blend-avatar svg {
            width: 24px;
            height: 24px;
            color: #666;
        }

        .blend-details {
            flex: 1;
        }

        .blend-name-edit {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .blend-name {
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .blend-name:hover {
            color: #888;
        }

        .blend-participants-count {
            font-size: 13px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 4px;
        }

        .participants-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .blend-actions-bar {
            display: flex;
            gap: 8px;
        }

        .now-playing-section {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .section-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 12px;
            font-weight: 600;
        }
        
            /* ensure overlay icons are sized and the heart can switch between outline/fill */
            #nowPlayingOverlay .overlay-btn svg { width: 22px; height: 22px; display: block; }
            #nowPlayingOverlay .overlay-btn svg { stroke: currentColor; }
            #nowPlayingOverlay .overlay-btn.like-active svg { fill: currentColor; stroke: none; }

        .now-playing-track {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .now-playing-cover {
            width: 64px;
            height: 64px;
            border-radius: 6px;
            object-fit: cover;
            background: #1a1a1a;
        }

        .now-playing-info {
            flex: 1;
        }

        .now-playing-title {
            font-size: 15px;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .now-playing-artist {
            font-size: 13px;
            color: #888;
        }

        .queue-section-blend {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .queue-item-blend {
            background: #000;
            border: 1px solid #1a1a1a;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: move;
            transition: all 0.2s;
        }

        .queue-item-blend:hover {
            background: #0a0a0a;
            border-color: #2a2a2a;
        }

        .drag-handle {
            color: #666;
            cursor: grab;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .drag-handle svg {
            width: 16px;
            height: 16px;
        }

        .queue-item-cover {
            width: 48px;
            height: 48px;
            border-radius: 4px;
            object-fit: cover;
            background: #1a1a1a;
        }

        .queue-item-info {
            flex: 1;
            min-width: 0;
        }

        .queue-item-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .queue-item-artist {
            font-size: 13px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .blend-search-section {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 16px;
        }

        .blend-search-bar {
            background: #000;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .blend-search-bar svg {
            width: 18px;
            height: 18px;
            color: #666;
        }

        .blend-search-input {
            flex: 1;
            background: none;
            border: none;
            color: #fafafa;
            font-family: 'Geist', sans-serif;
            font-size: 14px;
            outline: none;
        }

        .blend-search-input::placeholder {
            color: #666;
        }

        .blend-search-results {
            max-height: 300px;
            overflow-y: auto;
        }

        .empty-queue {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }

        .empty-queue svg {
            width: 48px;
            height: 48px;
            margin-bottom: 12px;
            opacity: 0.3;
        }

        /* Tablet Landscape & Desktop */
        @media (max-width: 1024px) {
            .sidebar {
                width: 240px;
                padding: 20px;
            }

            .logo {
                font-size: 28px;
                margin-bottom: 32px;
            }

            .main {
                padding: 20px;
            }

            .blend-container {
                max-width: 100%;
            }
        }

        /* Tablet Portrait */
        @media (max-width: 768px) {
            .app {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: auto;
                border-right: none;
                border-top: 1px solid #1a1a1a;
                padding: 12px 0;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 101;
                background: #0a0a0a;
                order: 3;
            }

            .logo {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                width: 100%;
                background: #0a0a0a;
                border-bottom: 1px solid #1a1a1a;
                padding: 10px 16px;
                margin-bottom: 0;
                z-index: 102;
                text-align: center;
                font-size: 26px;
            }

            nav {
                display: flex;
                justify-content: space-around;
                align-items: center;
                padding: 0 12px;
            }

            .nav-item {
                flex: 1;
                flex-direction: column;
                gap: 6px;
                margin-bottom: 0;
                padding: 10px 6px;
                text-align: center;
                justify-content: center;
                border-radius: 0;
                background: none;
            }

            .nav-item:hover {
                background: none;
            }

            .nav-item span {
                font-size: 11px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 100%;
            }

            .nav-item svg {
                width: 26px;
                height: 26px;
                flex-shrink: 0;
            }

            .nav-item.active {
                background: none;
                color: #fafafa;
            }

            .nav-item.active svg {
                color: #fafafa;
            }

            .main {
                padding: 0;
                padding-top: 75px;
                padding-bottom: 140px;
                order: 1;
            }

            .search-bar {
                max-width: 100%;
                margin: 16px;
                margin-bottom: 12px;
            }

            #searchResults,
            .tracks-grid {
                padding: 0 16px;
            }

            .section-title {
                font-size: 18px;
                padding: 0 16px;
            }

            .player-bar {
                padding: 12px 16px 16px;
                order: 2;
                height: auto;
                position: fixed;
                bottom: 75px;
                left: 0;
                right: 0;
                z-index: 102;
            }

            .player-content {
                flex-direction: column;
                gap: 12px;
                height: auto;
                padding: 0;
            }

            .player-track {
                width: 100%;
                order: 1;
                padding: 0;
            }

            .player-controls {
                order: 2;
                width: 100%;
                gap: 8px;
            }

            .controls-buttons {
                display: flex;
                justify-content: center;
                gap: 16px;
            }

            .control-button svg {
                width: 22px;
                height: 22px;
            }

            .control-button.play-btn {
                width: 42px;
                height: 42px;
            }

            .control-button.play-btn svg {
                width: 18px;
                height: 18px;
            }

            .progress-wrapper {
                max-width: 100%;
                gap: 8px;
            }

            .player-extra {
                display: none;
            }

            .blend-top-bar {
                flex-direction: column;
                align-items: flex-start;
                gap: 16px;
            }

            .blend-info {
                width: 100%;
            }

            .blend-actions-bar {
                width: 100%;
                justify-content: space-between;
            }


            .modal-content {
                max-width: 90%;
            }

            /* Blend mode: make boxes consistent and prevent cropping on narrow screens */
            .blend-container {
                width: 100%;
                box-sizing: border-box;
                padding: 0 12px;
            }

            .blend-top-bar,
            .now-playing-section,
            .queue-section-blend,
            .blend-search-section {
                width: calc(100% - 24px);
                box-sizing: border-box;
                padding: 14px 16px;
                margin: 0 12px 16px 12px;
                border-radius: 8px;
                overflow: hidden;
                background-clip: padding-box;
                background: #0a0a0a;
                border: 1px solid #1a1a1a;
            }

            .blend-top-bar .blend-info {
                width: 100%;
                min-width: 0;
                display: flex;
                gap: 12px;
                align-items: center;
            }

            .blend-top-bar .blend-details {
                flex: 1 1 auto;
                min-width: 0;
            }

            .blend-top-bar .blend-actions-bar {
                flex: 0 0 auto;
                display: flex;
                gap: 8px;
                align-items: center;
            }

            .queue-section-blend .section-label,
            .blend-search-section .section-label {
                padding-left: 2px;
            }

            .mobile-header {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: #0a0a0a;
                border-bottom: 1px solid #1a1a1a;
                padding: 16px;
                z-index: 102;
                font-family: 'Dancing Script', cursive;
                font-size: 26px;
                font-weight: 700;
                color: #fafafa;
                text-align: center;
            }
        }

        /* Mobile Landscape */
        @media (max-width: 640px) and (orientation: landscape) {
            .player-bar {
                padding: 8px 12px;
            }

            .player-content {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .player-track {
                width: 200px;
                order: 1;
            }

            .player-controls {
                flex: 1;
                order: 2;
                min-width: 300px;
            }

            .player-extra {
                width: auto;
                order: 3;
            }

            .main {
                padding-bottom: 100px;
            }
        }

        /* Mobile Portrait */
        @media (max-width: 480px) {
            body {
                overflow-x: hidden;
            }

            .mobile-logo {
                font-size: 24px;
                padding: 14px 16px;
            }

            .sidebar {
                padding: 10px 0;
                bottom: 0;
            }

            nav {
                padding: 0 8px;
            }

            .nav-item {
                padding: 8px 4px;
                gap: 5px;
                min-width: 0;
            }

            .nav-item span {
                font-size: 10px;
            }

            .nav-item svg {
                width: 24px;
                height: 24px;
            }

            .main {
                padding-top: 60px;
                padding-bottom: 120px;
                width: 100%;
                max-width: 100vw;
                overflow-x: hidden;
            }

            .search-bar {
                padding: 10px 16px;
                margin: 12px 12px 12px;
            }

            #searchResults,
            .tracks-grid {
                padding: 0 12px;
            }

            .search-input {
                font-size: 14px;
            }

            .section-title {
                font-size: 16px;
                margin-bottom: 12px;
                padding: 0 12px;
            }

            .track-card {
                padding: 8px;
                gap: 10px;
            }

            .track-cover {
                width: 48px;
                height: 48px;
            }

            .track-title {
                font-size: 13px;
            }

            .track-subtitle {
                font-size: 12px;
            }


            /* Download button states */
            .download-btn { position: relative; }
            /* show a small spinner overlay while downloading (keeps original svg hidden) */
            .download-btn.downloading svg { visibility: hidden; }
            .download-btn.downloading::after {
                content: '';
                position: absolute;
                left: 50%;
                top: 50%;
                width: 16px;
                height: 16px;
                margin-left: -8px;
                margin-top: -8px;
                border-radius: 50%;
                border: 2px solid rgba(255,255,255,0.12);
                border-top-color: #fff;
                box-sizing: border-box;
                animation: lf-spin 0.8s linear infinite;
            }
            @keyframes lf-spin { to { transform: rotate(360deg); } }
            /* Hide download icon when already downloaded */
            .download-btn.downloaded { display: none; }
            .icon-btn {
                padding: 6px;
            }

            .icon-btn svg {
                width: 16px;
                height: 16px;
            }

            .player-bar {
                padding: 10px 12px 12px;
                bottom: 65px;
            }

            .player-content {
                gap: 10px;
            }

            /* Mobile: make player title and controls share a single row */
            /* Use a grid to place title+controls on top row, seekbar on its own row */
            .player-bar .player-content {
                display: grid;
                grid-template-columns: 1fr auto;
                grid-template-rows: auto auto;
                grid-template-areas: "track controls" "progress progress";
                gap: 8px 12px;
                align-items: center;
            }

            .player-bar .player-track { grid-area: track; display: flex; align-items: center; gap: 10px; min-width: 0; }

            /* allow children of .player-controls to participate directly in the grid */
            .player-bar .player-controls { display: contents; }

            .player-bar .controls-buttons { grid-area: controls; justify-self: end; display: flex; gap: 12px; align-items: center; }

            .player-bar .progress-wrapper { grid-area: progress; width: 100%; }

            .player-bar .player-info { min-width: 0; overflow: hidden; }
            .player-bar .player-title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

            .player-track {
                padding: 0;
                gap: 8px;
            }

            .player-cover {
                width: 36px;
                height: 36px;
            }

            .player-title {
                font-size: 12px;
            }

            .player-artist {
                font-size: 10px;
            }

            .source-badge {
                font-size: 8px;
                padding: 1px 4px;
                margin-left: 4px;
            }

            .player-controls {
                padding: 0;
                gap: 6px;
            }

            .controls-buttons {
                gap: 12px;
            }

            .control-button svg {
                width: 20px;
                height: 20px;
            }

            .control-button.play-btn {
                width: 38px;
                height: 38px;
            }

            .control-button.play-btn svg {
                width: 16px;
                height: 16px;
            }

            .progress-wrapper {
                gap: 6px;
            }

            .time-label {
                font-size: 9px;
                min-width: 28px;
            }

            .progress-track {
                height: 4px;
            }

            .blend-top-bar {
                padding: 12px;
            }

            .blend-avatar {
                width: 40px;
                height: 40px;
            }

            .blend-avatar svg {
                width: 20px;
                height: 20px;
            }

            .blend-name {
                font-size: 14px;
            }

            .blend-participants-count {
                font-size: 11px;
            }

            .participants-dot {
                width: 4px;
                height: 4px;
            }

            .btn-small {
                padding: 5px 10px;
                font-size: 11px;
            }

            .now-playing-section,
            .queue-section-blend,
            .blend-search-section {
                padding: 12px;
                margin: 0 12px 12px;
            }

            .section-label {
                font-size: 10px;
                margin-bottom: 8px;
            }

            .now-playing-cover {
                width: 52px;
                height: 52px;
            }

            .now-playing-title {
                font-size: 13px;
            }

            .now-playing-artist {
                font-size: 11px;
            }

            .queue-item-blend {
                padding: 8px;
                gap: 8px;
                margin-bottom: 6px;
            }

            .queue-item-cover {
                width: 40px;
                height: 40px;
            }

            .queue-item-title {
                font-size: 12px;
            }

            .queue-item-artist {
                font-size: 11px;
            }

            .drag-handle svg {
                width: 14px;
                height: 14px;
            }

            .blend-search-bar {
                padding: 10px 12px;
                margin-bottom: 12px;
            }

            .blend-search-input {
                font-size: 13px;
            }

            .blend-search-results {
                max-height: 250px;
            }

            .modal-content {
                padding: 18px;
                max-width: 92%;
            }

            /* Small-screen tweaks for Blend mode */
            .blend-container {
                padding: 0 10px;
            }

            .blend-top-bar,
            .now-playing-section,
            .queue-section-blend,
            .blend-search-section {
                margin: 0 8px 12px 8px;
                padding: 10px 12px;
                border-radius: 8px;
                background: #0a0a0a;
                border: 1px solid #1a1a1a;
                box-sizing: border-box;
            }

            .blend-top-bar .blend-avatar {
                width: 44px;
                height: 44px;
            }

            .blend-top-bar .blend-details {
                min-width: 0;
            }

            /* Make Coming Next list items full-width and responsive */
            .queue-section-blend .queue-item-blend {
                width: 100%;
                box-sizing: border-box;
                padding: 10px;
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .queue-section-blend .queue-item-cover {
                width: 56px;
                height: 56px;
                flex-shrink: 0;
            }

            .queue-section-blend .queue-item-info {
                min-width: 0;
                flex: 1 1 auto;
                overflow: hidden;
            }

            .queue-section-blend .drag-handle {
                flex-shrink: 0;
                margin-right: 6px;
            }

            .modal-header {
                font-size: 15px;
                margin-bottom: 14px;
            }

            .form-label {
                font-size: 11px;
                margin-bottom: 5px;
            }

            .form-input {
                padding: 8px 10px;
                font-size: 13px;
            }

            .btn {
                padding: 8px;
                font-size: 12px;
            }

            .api-section {
                margin-bottom: 20px;
            }

            .api-header {
                padding-bottom: 6px;
                margin-bottom: 10px;
            }

            .api-name {
                font-size: 12px;
            }

            .api-count {
                font-size: 10px;
            }

            .empty-state,
            .empty-queue {
                padding: 30px 12px;
            }

            .empty-state svg,
            .empty-queue svg {
                width: 40px;
                height: 40px;
                margin-bottom: 10px;
            }

            .empty-state p,
            .empty-queue p {
                font-size: 13px;
            }
        }

        /* Small Mobile */
        @media (max-width: 360px) {
            .mobile-logo {
                font-size: 22px;
                padding: 12px 14px;
            }

            .sidebar {
                bottom: 0;
                padding: 8px 0;
            }

            nav {
                padding: 0 6px;
            }

            .nav-item {
                padding: 7px 3px;
                gap: 4px;
            }

            .nav-item span {
                font-size: 9px;
            }

            .nav-item svg {
                width: 22px;
                height: 22px;
            }

            .main {
                padding-bottom: 120px;
            }

            .search-bar {
                padding: 8px 14px;
                margin: 10px 10px;
            }

            #searchResults,
            .tracks-grid {
                padding: 0 10px;
            }

            .section-title {
                padding: 0 10px;
            }

            .track-card {
                padding: 6px;
                gap: 8px;
            }

            .track-cover,
            .queue-item-cover {
                width: 40px;
                height: 40px;
            }

            .track-title {
                font-size: 12px;
            }

            .track-subtitle {
                font-size: 11px;
            }

            .track-actions {
                gap: 4px;
            }

            .icon-btn {
                padding: 4px;
            }

            .icon-btn svg {
                width: 14px;
                height: 14px;
            }

            .player-bar {
                padding: 8px 10px 10px;
                bottom: 60px;
            }

            .player-content {
                gap: 8px;
            }

            .player-track {
                gap: 6px;
            }

            .player-cover {
                width: 32px;
                height: 32px;
            }

            .player-title {
                font-size: 11px;
            }

            .player-artist {
                font-size: 9px;
            }

            .source-badge {
                display: none;
            }

            .controls-buttons {
                gap: 10px;
            }

            .control-button svg {
                width: 18px;
                height: 18px;
            }

            .control-button.play-btn {
                width: 34px;
                height: 34px;
            }

            .control-button.play-btn svg {
                width: 14px;
                height: 14px;
            }

            .time-label {
                font-size: 8px;
                min-width: 24px;
            }

            .progress-track {
                height: 3px;
            }

            .blend-top-bar {
                padding: 12px;
            }

            .blend-avatar {
                width: 36px;
                height: 36px;
            }

            .blend-avatar svg {
                width: 18px;
                height: 18px;
            }

            .blend-name {
                font-size: 13px;
            }

            .blend-participants-count {
                font-size: 10px;
            }

            .blend-actions-bar {
                flex-wrap: wrap;
                gap: 6px;
            }

            .btn-small {
                padding: 4px 8px;
                font-size: 10px;
            }

            .now-playing-section,
            .queue-section-blend,
            .blend-search-section {
                padding: 12px;
                margin: 0 12px 12px;
            }

            .section-label {
                font-size: 10px;
                margin-bottom: 8px;
            }

            .now-playing-cover {
                width: 48px;
                height: 48px;
            }

            .now-playing-title {
                font-size: 13px;
            }

            .now-playing-artist {
                font-size: 11px;
            }

            .queue-item-blend {
                padding: 6px;
                gap: 6px;
                margin-bottom: 6px;
            }

            .queue-item-cover {
                width: 36px;
                height: 36px;
            }

            .queue-item-title {
                font-size: 12px;
            }

            .queue-item-artist {
                font-size: 11px;
            }

            .drag-handle svg {
                width: 14px;
                height: 14px;
            }

            .blend-search-bar {
                padding: 10px 12px;
                margin-bottom: 12px;
            }

            .blend-search-input {
                font-size: 13px;
            }

            .blend-search-results {
                max-height: 250px;
            }

            .modal-content {
                padding: 18px;
                max-width: 92%;
            }

            /* Small-screen tweaks for Blend mode */
            .blend-container {
                padding: 0 10px;
            }

            .blend-top-bar,
            .now-playing-section,
            .queue-section-blend,
            .blend-search-section {
                margin: 0 8px 12px 8px;
                padding: 10px 12px;
                border-radius: 8px;
                background: #0a0a0a;
                border: 1px solid #1a1a1a;
                box-sizing: border-box;
            }

            .blend-top-bar .blend-avatar {
                width: 44px;
                height: 44px;
            }

            .blend-top-bar .blend-details {
                min-width: 0;
            }

            /* Make Coming Next list items full-width and responsive */
            .queue-section-blend .queue-item-blend {
                width: 100%;
                box-sizing: border-box;
                padding: 10px;
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .queue-section-blend .queue-item-cover {
                width: 56px;
                height: 56px;
                flex-shrink: 0;
            }

            .queue-section-blend .queue-item-info {
                min-width: 0;
                flex: 1 1 auto;
                overflow: hidden;
            }

            .queue-section-blend .drag-handle {
                flex-shrink: 0;
                margin-right: 6px;
            }

            .modal-header {
                font-size: 15px;
                margin-bottom: 14px;
            }

            .form-label {
                font-size: 11px;
                margin-bottom: 5px;
            }

            .form-input {
                padding: 8px 10px;
                font-size: 13px;
            }

            .btn {
                padding: 8px;
                font-size: 12px;
            }

            .api-section {
                margin-bottom: 20px;
            }

            .api-header {
                padding-bottom: 6px;
                margin-bottom: 10px;
            }

            .api-name {
                font-size: 12px;
            }

            .api-count {
                font-size: 10px;
            }

            .empty-state,
            .empty-queue {
                padding: 30px 12px;
            }

            .empty-state svg,
            .empty-queue svg {
                width: 40px;
                height: 40px;
                margin-bottom: 10px;
            }

            .empty-state p,
            .empty-queue p {
                font-size: 13px;
            }
        }

        /* Small Mobile */
        @media (max-width: 360px) {
            .mobile-logo {
                font-size: 22px;
                padding: 12px 14px;
            }

            .sidebar {
                bottom: 0;
                padding: 8px 0;
            }

            nav {
                padding: 0 6px;
            }

            .nav-item {
                padding: 7px 3px;
                gap: 4px;
            }

            .nav-item span {
                font-size: 9px;
            }

            .nav-item svg {
                width: 22px;
                height: 22px;
            }

            .main {
                padding-bottom: 230px;
            }

            .search-bar {
                padding: 8px 14px;
                margin: 10px 10px;
            }

            #searchResults,
            .tracks-grid {
                padding: 0 10px;
            }

            .section-title {
                padding: 0 10px;
            }

            .track-card {
                padding: 6px;
                gap: 8px;
            }

            .track-cover,
            .queue-item-cover {
                width: 40px;
                height: 40px;
            }

            .track-title {
                font-size: 12px;
            }

            .track-subtitle {
                font-size: 11px;
            }

            .track-actions {
                gap: 4px;
            }

            .icon-btn {
                padding: 4px;
            }

            .icon-btn svg {
                width: 14px;
                height: 14px;
            }

            .player-bar {
                padding: 8px 10px 10px;
                bottom: 60px;
            }

            .player-content {
                gap: 8px;
            }

            .player-track {
                gap: 6px;
            }

            .player-cover {
                width: 32px;
                height: 32px;
            }

            .player-title {
                font-size: 11px;
            }

            .player-artist {
                font-size: 9px;
            }

            .source-badge {
                display: none;
            }

            .controls-buttons {
                gap: 10px;
            }

            .control-button svg {
                width: 18px;
                height: 18px;
            }

            .control-button.play-btn {
                width: 34px;
                height: 34px;
            }

            .control-button.play-btn svg {
                width: 14px;
                height: 14px;
            }

            .time-label {
                font-size: 8px;
                min-width: 24px;
            }

            .progress-track {
                height: 3px;
            }

            .blend-top-bar {
                padding: 12px;
            }

            .blend-avatar {
                width: 36px;
                height: 36px;
            }

            .blend-avatar svg {
                width: 18px;
                height: 18px;
            }

            .blend-name {
                font-size: 13px;
            }

            .blend-participants-count {
                font-size: 10px;
            }

            .blend-actions-bar {
                flex-wrap: wrap;
                gap: 6px;
            }

            .btn-small {
                padding: 4px 8px;
                font-size: 10px;
            }

            .now-playing-section,
            .queue-section-blend,
            .blend-search-section {
                padding: 12px;
                margin: 0 12px 12px;
            }

            .section-label {
                font-size: 10px;
                margin-bottom: 8px;
            }

            .now-playing-cover {
                width: 48px;
                height: 48px;
            }

            .now-playing-title {
                font-size: 13px;
            }

            .now-playing-artist {
                font-size: 11px;
            }

            .queue-item-blend {
                padding: 6px;
                gap: 6px;
                margin-bottom: 6px;
            }

            .queue-item-cover {
                width: 36px;
                height: 36px;
            }

            .queue-item-title {
                font-size: 12px;
            }

            .queue-item-artist {
                font-size: 11px;
            }

            .drag-handle svg {
                width: 14px;
                height: 14px;
            }

            .blend-search-bar {
                padding: 10px 12px;
                margin-bottom: 12px;
            }

            .blend-search-input {
                font-size: 13px;
            }

            .blend-search-results {
                max-height: 250px;
            }

            .modal-content {
                padding: 18px;
                max-width: 92%;
            }

            /* Small-screen tweaks for Blend mode */
            .blend-container {
                padding: 0 10px;
            }

            .blend-top-bar,
            .now-playing-section,
            .queue-section-blend,
            .blend-search-section {
                margin: 0 8px 12px 8px;
                padding: 10px 12px;
                border-radius: 8px;
                background: #0a0a0a;
                border: 1px solid #1a1a1a;
                box-sizing: border-box;
            }

            .blend-top-bar .blend-avatar {
                width: 44px;
                height: 44px;
            }

            .blend-top-bar .blend-details {
                min-width: 0;
            }

            /* Make Coming Next list items full-width and responsive */
            .queue-section-blend .queue-item-blend {
                width: 100%;
                box-sizing: border-box;
                padding: 10px;
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .queue-section-blend .queue-item-cover {
                width: 56px;
                height: 56px;
                flex-shrink: 0;
            }

            .queue-section-blend .queue-item-info {
                min-width: 0;
                flex: 1 1 auto;
                overflow: hidden;
            }

            .queue-section-blend .drag-handle {
                flex-shrink: 0;
                margin-right: 6px;
            }

            .modal-header {
                font-size: 15px;
                margin-bottom: 14px;
            }

            .form-label {
                font-size: 11px;
                margin-bottom: 5px;
            }

            .form-input {
                padding: 8px 10px;
                font-size: 13px;
            }

            .btn {
                padding: 8px;
                font-size: 12px;
            }

            .api-section {
                margin-bottom: 20px;
            }

            .api-header {
                padding-bottom: 6px;
                margin-bottom: 10px;
            }

            .api-name {
                font-size: 12px;
            }

            .api-count {
                font-size: 10px;
            }

            .empty-state,
            .empty-queue {
                padding: 30px 12px;
            }

            .empty-state svg,
            .empty-queue svg {
                width: 40px;
                height: 40px;
                margin-bottom: 10px;
            }

            .empty-state p,
            .empty-queue p {
                font-size: 13px;
            }
        }

        /* Install banner styles (responsive) */
        #install-banner {
            position: fixed;
            left: 12px;
            right: 12px;
            bottom: calc(84px + env(safe-area-inset-bottom, 0px));
            z-index: 2000;
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            padding: 12px;
            border-radius: 12px;
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            max-width: 820px;
            margin: 0 auto;
            box-sizing: border-box;
            color: #fafafa;
            font-family: 'Geist', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        #install-banner .install-left {
            display: flex;
            gap: 12px;
            align-items: center;
            min-width: 0;
            flex: 1 1 auto;
        }

        #install-banner .install-icon {
            width: 56px;
            height: 56px;
            border-radius: 10px;
            object-fit: cover;
            flex: 0 0 auto;
        }

        #install-banner .install-text {
            overflow: hidden;
            min-width: 0;
        }

        #install-banner .install-text > div:first-child {
            font-weight: 700;
            font-size: 15px;
        }

        #install-banner .install-text > div:nth-child(2) {
            color: #9a9a9a;
            font-size: 12px;
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #install-banner .install-actions {
            display: flex;
            gap: 8px;
            flex: 0 0 auto;
            align-items: center;
        }

        .install-btn {
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
        }

        .install-primary { background: #fafafa; color: #000; }
        .install-secondary { background: transparent; color: #fafafa; border: 1px solid rgba(255,255,255,0.06); }
        .install-cancel { background: transparent; color: #9a9a9a; }

        /* Responsive: stack on narrow screens */
        @media (max-width: 520px) {
            #install-banner { flex-direction: column; align-items: stretch; padding: 12px; }
            #install-banner .install-left { gap: 10px; }
            #install-banner .install-actions { flex-direction: column; gap: 8px; margin-top: 8px; }
            .install-btn { width: 100%; }
            #install-banner .install-icon { width: 48px; height: 48px; }
        }
        /* Home credits */
        .home-credit { margin: 18px 0 12px; color: #9a9a9a; font-size: 13px; max-width: 1200px; }
        .home-credit a { color: #fafafa; text-decoration: none; border-bottom: 1px solid rgba(255,255,255,0.06); padding-bottom: 1px; }
        .home-credit a:hover { color: #fff; text-decoration: underline; }
        @media (max-width:480px) {
            .home-credit { margin: 12px 8px 12px; font-size: 13px; }
        }

        /* Imported grids from new.html (desktop mosaic + responsive rules) */
        .extra-bento-section { width:100%; max-width:1400px; margin:18px auto 0; }
        .extra-bento-grid {
            display: grid;
            /* use fewer columns on desktop so each tile is larger/square-ish for album art */
            grid-template-columns: repeat(3, 1fr);
            gap: 18px;
            width: 100%;
            box-sizing: border-box;
            max-width: 1400px;
            margin: 0 auto;
            /* taller rows so square artwork isn't squeezed; will be spanned for large tiles */
            grid-auto-rows: 220px;
        }

        .extra-bento-item {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.24s ease, box-shadow 0.24s ease;
            position: relative;
            height: 100%;
            display: block;
            box-shadow: 0 6px 18px rgba(0,0,0,0.45);
        }

        .extra-bento-item img { width: 100%; height: 100%; object-fit: cover; display: block; }

        .extra-bento-item .overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 18px;
            background: linear-gradient(to top, rgba(0,0,0,0.92), transparent);
            box-sizing: border-box;
        }

        .extra-bento-item .title { font-size: 18px; font-weight: 700; margin-bottom: 6px; color: #fff; }
        .extra-bento-item .subtitle { font-size: 14px; color: #cfcfcf; }

        /* spanning rules to match new.html mosaic */
        .extra-bento-item.large { grid-column: span 2; grid-row: span 2; }
        .extra-bento-item.wide { grid-column: span 2; }
        .extra-bento-item.tall { grid-row: span 2; }

        @media (max-width: 1024px) {
            .extra-bento-grid { grid-template-columns: repeat(3, 1fr); grid-auto-rows: 140px; }
        }

        @media (max-width: 768px) {
            .extra-bento-grid { grid-template-columns: repeat(6, 1fr); gap:12px; grid-auto-rows: 100px; }
            .extra-bento-item { height: auto; }
            .extra-bento-item.large { grid-column: span 6; grid-row: span 1; }
            .extra-bento-item.wide { grid-column: span 4; }
            .extra-bento-item.tall { grid-column: span 2; grid-row: span 2; }
        }

        @media (max-width: 480px) {
            /* Responsive auto-fit grid: fills rows and avoids empty column gaps */
            .extra-bento-grid { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap:10px; grid-auto-rows: auto; }
            .extra-bento-item { aspect-ratio: 1 / 1; min-height: 110px; }
            /* Make large tiles span the full row regardless of column count */
            .extra-bento-item.large { grid-column: 1 / -1; grid-row: span 1; }
            .extra-bento-item.wide { grid-column: span 2; }
            .extra-bento-item.tall { grid-row: span 2; grid-column: span 1; }
        }

        /* Now-playing overlay: uses smooth slide-up animation */
        #nowPlayingOverlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            z-index: 3000;
            background: rgba(0,0,0,0);
            pointer-events: none;
            transition: background-color 420ms cubic-bezier(.22,1,.36,1);
        }

        #nowPlayingOverlay.active {
            background: rgba(0,0,0,0.92);
            pointer-events: auto;
        }

        /* overlay-card fills the viewport so the overlay feels like a full-screen player */
        #nowPlayingOverlay .overlay-card {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 28px;
            padding-top: 80px; 
            box-sizing: border-box;
            display: flex;
            gap: 28px;
            align-items: center;
            justify-content: center;
            flex-direction: row;
            position: relative;
            transform: translateY(100%);
            transition: transform 480ms cubic-bezier(.22,1,.36,1);
        }

        #nowPlayingOverlay.active .overlay-card {
            transform: translateY(0);
        }

        /* close button */
        #nowPlayingOverlay .overlay-close {
            position: absolute;
            top: 18px;
            left: 18px;
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: none;
            background: rgba(255,255,255,0.03);
            color: #fff;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 40;
        }

        #nowPlayingOverlay .overlay-close:active { transform: scale(0.98); }

        /* artwork */
        #nowPlayingOverlay .overlay-cover {
            /* reduced default desktop artwork width for a tighter layout */
            width: min(520px, 40%);
            height: auto;
            max-height: 80vh;
            border-radius: 12px;
            object-fit: cover;
            background: #111;
            flex: 0 0 auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
        }

        #nowPlayingOverlay .overlay-info { flex: 1 1 auto; min-width: 0; color: #fafafa; padding: 12px 6px; }

        #nowPlayingOverlay .overlay-title { font-size: 28px; font-weight: 800; margin-bottom: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #nowPlayingOverlay .overlay-artist { font-size: 16px; color: #bdbdbd; margin-bottom: 18px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* overlay controls (will be placed inside .overlay-bottom) */
        #nowPlayingOverlay .overlay-controls {
            display:flex;
            align-items:center;
            gap:16px;
            margin:0;
            background: transparent;
        }

        /* bottom container that anchors controls, seekbar and times to the bottom */
        #nowPlayingOverlay .overlay-bottom {
            position: absolute;
            left: 0;
            right: 0;
            bottom: calc(28px + env(safe-area-inset-bottom, 0px));
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 0 24px;
            z-index: 30;
        }

        #nowPlayingOverlay .overlay-btn { width:56px; height:56px; border-radius:12px; border:none; background:#111; color:#fafafa; display:flex; align-items:center; justify-content:center; cursor:pointer; }

        /* heart/like state for overlay button */
        #nowPlayingOverlay .overlay-btn.like-active { color: #ff6b6b; background: rgba(255,107,107,0.06); }

        #nowPlayingOverlay .overlay-progress { width:100%; display:block; height:10px; background:#121212; border-radius:6px; position:relative; cursor:pointer; }

        #nowPlayingOverlay .overlay-progress .bar { height:100%; background:#ffffff; width:0%; border-radius:6px; }

        #nowPlayingOverlay .overlay-times { display:flex; justify-content:space-between; color:#9a9a9a; font-size:13px; margin-top:8px; width:100%; box-sizing:border-box; }
        @media (max-width:720px) {
            #nowPlayingOverlay .overlay-card { flex-direction: column; align-items: center; padding: 18px 14px 14px; padding-top: 110px; }
            #nowPlayingOverlay .overlay-cover { width: min(90%, 420px); max-height: 60vh; margin-top: 8px; }
            #nowPlayingOverlay .overlay-info { padding: 8px 0; text-align: center; }
            #nowPlayingOverlay .overlay-title { font-size: 20px; }
            #nowPlayingOverlay .overlay-artist { font-size: 14px; }
            #nowPlayingOverlay .overlay-controls { position: static; left: auto; transform: none; bottom: auto; margin: 14px 0 8px; justify-content: center; }
            #nowPlayingOverlay .overlay-btn { width: 64px; height: 64px; border-radius: 14px; }
            #nowPlayingOverlay .overlay-progress { width: calc(100% - 40px); height: 14px; border-radius: 8px; margin-top: 8px; }
            #nowPlayingOverlay .overlay-progress .bar { height: 100%; border-radius: 8px; }
            #nowPlayingOverlay .overlay-times { width: calc(100% - 40px); }
        }

        /* Make overlay controls responsive to avoid horizontal cropping on narrow phones */
        @media (max-width:720px) {
            #nowPlayingOverlay .overlay-bottom { padding-left: env(safe-area-inset-left, 16px); padding-right: env(safe-area-inset-right, 16px); box-sizing: border-box; }
            /* keep large icon sizes but allow wrapping into multiple rows to avoid cropping */
            #nowPlayingOverlay .overlay-controls { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; max-width: 100%; box-sizing: border-box; }
            #nowPlayingOverlay .overlay-controls .overlay-btn { width: 64px; height: 64px; }
        }

        @media (max-width:480px) {
            #nowPlayingOverlay .overlay-controls { gap: 8px; }
            /* keep icons large on narrow phones; wrapping prevents horizontal cropping */
            #nowPlayingOverlay .overlay-controls .overlay-btn { width: 64px; height: 64px; border-radius: 12px; }
            #nowPlayingOverlay .overlay-bottom { padding-left: 12px; padding-right: 12px; }
            /* ensure progress and times stack nicely */
            #nowPlayingOverlay .overlay-progress { width: calc(100% - 24px); }
            #nowPlayingOverlay .overlay-times { width: calc(100% - 24px); }
        }

        /* Slightly smaller sizes on very narrow devices to avoid any edge-cropping */
        @media (max-width:420px) {
            #nowPlayingOverlay .overlay-controls .overlay-btn { width: 56px; height: 56px; }
            #nowPlayingOverlay .overlay-controls .overlay-btn svg { width: 20px; height: 20px; }
        }

        @media (max-width:360px) {
            #nowPlayingOverlay .overlay-controls .overlay-btn { width: 52px; height: 52px; }
            #nowPlayingOverlay .overlay-controls .overlay-btn svg { width: 18px; height: 18px; }
        }
        /* Home view greeting */
        /* Left-align Home content on desktop so tiles sit to the left column */
        #homeView { display: flex; flex-direction: column; align-items: flex-start; justify-content: flex-start; padding: 40px 20px; color: #fafafa; }
        .home-greeting { font-size: 44px; font-weight: 800; margin-bottom: 8px; text-align: left; width: 100%; }
        @media (max-width:720px) {
            /* left-align and reduce padding/font-size on phones */
            #homeView { align-items: flex-start; padding-top: 20px; padding-left: 18px; padding-right: 18px; }
            .home-greeting { font-size: 28px; text-align: left; margin-bottom: 6px; }
        }
        @media (max-width:480px) {
            /* Tighter mobile layout: smaller greeting and compact action tiles */
            .home-greeting { font-size: 24px; margin-left: 4px; margin-bottom: 10px; }
            /* Keep top action tiles in their original horizontal layout on phones */
            .home-bento { grid-template-columns: repeat(2, 1fr); gap: 10px; max-width: calc(100% - 32px); }
            .bento-tile {
                padding: 10px;
                border-radius: 10px;
                display: flex;
                align-items: center;
                gap: 12px;
            }
            .bento-img { width:48px; height:48px; margin-bottom:0; }
            .bento-label { font-size: 14px; }

            /* Extra grids compact: styles consolidated earlier to avoid duplicates */

            /* prevent large artwork from pushing too far on phones */
            #nowPlayingOverlay .overlay-cover { max-height: 40vh; width: 100%; }
        }
        /* Bento grid: show 4 action tiles on desktop */
        .home-bento { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; width: 100%; max-width: 1200px; margin-top: 18px; }
        .bento-tile { background: rgba(255,255,255,0.02); border-radius: 12px; padding: 12px; display:flex; align-items:center; gap:12px; cursor:pointer; transition: transform .12s ease, background .12s ease; }
        .bento-tile:hover { transform: translateY(-4px); background: rgba(255,255,255,0.03); }
        .bento-img { width:64px; height:64px; object-fit:cover; border-radius:8px; flex:0 0 auto; }
        .bento-label { font-size:16px; font-weight:700; }
        @media (max-width:720px) {
            .home-bento { grid-template-columns: 1fr 1fr; gap:12px; margin-top:12px; }
            .bento-img { width:56px; height:56px; }
            .bento-label { font-size:14px; }
        }

        /* Install banner styles (responsive) */
        #install-banner {
            position: fixed;
            left: 12px;
            right: 12px;
            bottom: calc(84px + env(safe-area-inset-bottom, 0px));
            z-index: 2000;
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            padding: 12px;
            border-radius: 12px;
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            max-width: 820px;
            margin: 0 auto;
            box-sizing: border-box;
            color: #fafafa;
            font-family: 'Geist', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        #install-banner .install-left {
            display: flex;
            gap: 12px;
            align-items: center;
            min-width: 0;
            flex: 1 1 auto;
        }

        #install-banner .install-icon {
            width: 56px;
            height: 56px;
            border-radius: 10px;
            object-fit: cover;
            flex: 0 0 auto;
        }

        #install-banner .install-text {
            overflow: hidden;
            min-width: 0;
        }

        #install-banner .install-text > div:first-child {
            font-weight: 700;
            font-size: 15px;
        }

        #install-banner .install-text > div:nth-child(2) {
            color: #9a9a9a;
            font-size: 12px;
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #install-banner .install-actions {
            display: flex;
            gap: 8px;
            flex: 0 0 auto;
            align-items: center;
        }

        .install-btn {
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
        }

        .install-primary { background: #fafafa; color: #000; }
        .install-secondary { background: transparent; color: #fafafa; border: 1px solid rgba(255,255,255,0.06); }
        .install-cancel { background: transparent; color: #9a9a9a; }

        /* Responsive: stack on narrow screens */
        @media (max-width: 520px) {
            #install-banner { flex-direction: column; align-items: stretch; padding: 12px; }
            #install-banner .install-left { gap: 10px; }
            #install-banner .install-actions { flex-direction: column; gap: 8px; margin-top: 8px; }
            .install-btn { width: 100%; }
            #install-banner .install-icon { width: 48px; height: 48px; }
        }
    </style>
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/listenfreely.png">
    <meta name="theme-color" content="#000000">
    <script defer>
        // PWA install banner + service worker registration + auto-update
        (function(){
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;

            // Create a simple install banner element (only shown in browser, not when PWA is installed)
            let deferredPrompt = null;
            function createInstallBanner() {
                const existing = document.getElementById('install-banner');
                if (existing) return existing;
                const banner = document.createElement('div');
                banner.id = 'install-banner';
                banner.className = 'install-banner';

                const left = document.createElement('div');
                left.className = 'install-left';

                const img = document.createElement('img');
                img.src = '/listenfreely.png';
                img.className = 'install-icon';
                left.appendChild(img);

                const text = document.createElement('div');
                text.className = 'install-text';
                text.innerHTML = '<div>Install ListenFreely</div><div>Open quickly from your home screen and keep it updated</div>';
                left.appendChild(text);

                const actions = document.createElement('div');
                actions.className = 'install-actions';

                const installBtn = document.createElement('button');
                installBtn.innerText = 'Install';
                installBtn.className = 'install-btn install-primary';
                installBtn.onclick = async () => {
                    if (!deferredPrompt) return;
                    deferredPrompt.prompt();
                    const choice = await deferredPrompt.userChoice;
                    deferredPrompt = null;
                    hideBanner();
                };

                const cancelBtn = document.createElement('button');
                cancelBtn.innerText = 'Cancel';
                cancelBtn.className = 'install-btn install-cancel';
                cancelBtn.onclick = hideBanner;

                actions.appendChild(installBtn);
                actions.appendChild(cancelBtn);

                banner.appendChild(left);
                banner.appendChild(actions);
                document.body.appendChild(banner);
                return banner;
            }

            function showBanner() {
                if (isStandalone) return;
                const b = createInstallBanner();
                b.style.display = 'flex';
            }
            function hideBanner() {
                const b = document.getElementById('install-banner');
                if (!b) return;
                b.style.display = 'none';
            }

            window.addEventListener('beforeinstallprompt', (e) => {
                // Prevent automatic mini-infobar on mobile
                e.preventDefault();
                deferredPrompt = e;
                showBanner();
            });

            // Don't show install UI when already running as PWA
            if (isStandalone) hideBanner();

            // Register Service Worker and enable immediate updates
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', async () => {
                    try {
                        const registration = await navigator.serviceWorker.register('/service-worker.js', {scope:'/'});

                        // If there's an updated worker waiting, ask it to skipWaiting immediately
                        if (registration.waiting) {
                            registration.waiting.postMessage({type: 'SKIP_WAITING'});
                        }

                        // Listen for updates found in the future
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            if (!newWorker) return;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed') {
                                    // New content available  activate immediately
                                    if (navigator.serviceWorker.controller) {
                                        newWorker.postMessage({type: 'SKIP_WAITING'});
                                    }
                                }
                            });
                        });

                        // When the new service worker takes control, reload so user sees updated app
                        navigator.serviceWorker.addEventListener('controllerchange', () => {
                            window.location.reload();
                        });
                    } catch (err) {
                        console.error('ServiceWorker registration failed:', err);
                    }
                });
            }
        })();
    </script>
</head>

<body>
    <div class="app">
        <aside class="sidebar">
            <div class="logo">ListenFreely</div>
            <nav>
                <div class="nav-item active" data-view="home">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M4.18753 11.3788C4.03002 11.759 4 11.9533 4 12V20.0018C4 20.5529 4.44652 21 5 21H8V15C8 13.8954 8.89543 13 10 13H14C15.1046 13 16 13.8954 16 15V21H19C19.5535 21 20 20.5529 20 20.0018V12C20 11.9533 19.97 11.759 19.8125 11.3788C19.6662 11.0256 19.4443 10.5926 19.1547 10.1025C18.5764 9.1238 17.765 7.97999 16.8568 6.89018C15.9465 5.79788 14.9639 4.78969 14.0502 4.06454C13.5935 3.70204 13.1736 3.42608 12.8055 3.2444C12.429 3.05862 12.1641 3 12 3C11.8359 3 11.571 3.05862 11.1945 3.2444C10.8264 3.42608 10.4065 3.70204 9.94978 4.06454C9.03609 4.78969 8.05348 5.79788 7.14322 6.89018C6.23505 7.97999 5.42361 9.1238 4.8453 10.1025C4.55568 10.5926 4.33385 11.0256 4.18753 11.3788ZM10.3094 1.45091C10.8353 1.19138 11.4141 1 12 1C12.5859 1 13.1647 1.19138 13.6906 1.45091C14.2248 1.71454 14.7659 2.07921 15.2935 2.49796C16.3486 3.33531 17.4285 4.45212 18.3932 5.60982C19.3601 6.77001 20.2361 8.0012 20.8766 9.08502C21.1963 9.62614 21.4667 10.1462 21.6602 10.6134C21.8425 11.0535 22 11.5467 22 12V20.0018C22 21.6599 20.6557 23 19 23H16C14.8954 23 14 22.1046 14 21V15H10V21C10 22.1046 9.10457 23 8 23H5C3.34434 23 2 21.6599 2 20.0018V12C2 11.5467 2.15748 11.0535 2.33982 10.6134C2.53334 10.1462 2.80369 9.62614 3.12345 9.08502C3.76389 8.0012 4.63995 6.77001 5.60678 5.60982C6.57152 4.45212 7.65141 3.33531 8.70647 2.49796C9.2341 2.07921 9.77521 1.71454 10.3094 1.45091Z" />
                    </svg>
                    <span>Home</span>
                </div>
                <div class="nav-item" data-view="search">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                    </svg>
                    <span>Search</span>
                </div>
                <div class="nav-item" data-view="recent">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>Recents</span>
                </div>
                <div class="nav-item" data-view="liked">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                    </svg>
                    <span>Liked</span>
                </div>
                <div class="nav-item" data-view="downloads">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v12m0 0l4-4m-4 4l-4-4M21 21H3" />
                    </svg>
                    <span>Downloads</span>
                </div>
                <div class="nav-item" data-view="blend">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                    </svg>
                    <span>Blend</span>
                </div>
            </nav>
        </aside>

        <main class="main" id="mainContent">
            <div id="homeView" style="display:none;">
                <div class="home-greeting" id="homeGreeting">Good day</div>
                <div class="home-bento" id="homeBento">
                    <div class="bento-tile" data-target="mostPlayed">
                        <img class="bento-img" src="/listenfreely.png" alt="Most Played">
                        <div class="bento-label">Most Played</div>
                    </div>
                    <div class="bento-tile" data-target="liked">
                        <img class="bento-img" src="/listenfreely.png" alt="Liked Songs">
                        <div class="bento-label">Liked Songs</div>
                    </div>
                    <div class="bento-tile" data-target="recent">
                        <img class="bento-img" src="/listenfreely.png" alt="Recently Played">
                        <div class="bento-label">Recently Played</div>
                    </div>
                    <div class="bento-tile" data-target="blend">
                        <img class="bento-img" src="/listenfreely.png" alt="Blend">
                        <div class="bento-label">Listen Together</div>
                    </div>
                </div>
                <!-- Imported grids from new.html -->
                <div class="extra-bento-section" id="extraBentoSection" style="width:100%; max-width:1400px; margin-top:20px;">
                    <div class="extra-bento-grid" id="extraBentoGrid"></div>
                </div>
                <div class="home-credit" id="homeCredit" aria-label="Credits">Created by <a href="https://aryansrao.github.io" target="_blank" rel="noopener noreferrer">Aryan S Rao</a>  <a href="https://github.com/aryansrao/listenfreely" target="_blank" rel="noopener noreferrer">GitHub</a>  <a href="https://aryansrao.github.io/support/" target="_blank" rel="noopener noreferrer">Support Me</a></div>
            </div>

            <div id="searchView">
                <div class="search-bar">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                    </svg>
                    <input type="text" class="search-input" placeholder="Search songs, artists, albums..."
                        id="searchInput">
                </div>
                <div id="searchResults"></div>
            </div>

            <div id="recentView" style="display: none;">
                <h2 class="section-title">Recents</h2>
                <div class="tracks-grid" id="recentTracks"></div>
            </div>

            <div id="likedView" style="display: none;">
                <h2 class="section-title">Liked Songs</h2>
                <div class="tracks-grid" id="likedTracks"></div>
            </div>

            <div id="downloadsView" style="display: none;">
                <h2 class="section-title">Downloads</h2>
                <div class="tracks-grid" id="downloadsList"></div>
            </div>

            <div id="blendView" style="display: none;">
                <div class="blend-container">
                    <div id="blendInitial">
                        <h2 class="section-title">Listen Together</h2>
                        <div
                            style="background: #0a0a0a; border: 1px solid #1a1a1a; border-radius: 8px; padding: 40px; text-align: center;">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"
                                style="width: 64px; height: 64px; margin: 0 auto 16px; opacity: 0.3;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                            </svg>
                            <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">Start Listening Together
                            </div>
                            <div style="font-size: 14px; color: #888; margin-bottom: 24px;">Create a session or join
                                your friends</div>
                            <div style="display: flex; gap: 8px; justify-content: center;">
                                <button class="btn btn-primary" id="createBlendBtn">Create Session</button>
                                <button class="btn btn-secondary" id="joinBlendBtn">Join Session</button>
                            </div>
                        </div>
                    </div>

                    <div id="blendActive" style="display: none;">
                        <div class="blend-top-bar">
                            <div class="blend-info">
                                <div class="blend-avatar" id="blendAvatar">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                                    </svg>
                                    <input type="file" id="blendAvatarInput" accept="image/*" style="display: none;">
                                </div>
                                <div class="blend-details">
                                    <div class="blend-name-edit">
                                        <div class="blend-name" id="blendNameDisplay">My Blend</div>
                                        <button class="icon-btn" id="editBlendNameBtn" style="padding: 4px;">
                                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"
                                                style="width: 14px; height: 14px;">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                                            </svg>
                                        </button>
                                    </div>
                                    <div class="blend-participants-count">
                                        <div class="participants-dot"></div>
                                        <span id="participantCount">1 listener</span>
                                    </div>
                                </div>
                            </div>
                            <div class="blend-actions-bar">
                                <button class="icon-btn" id="shareBlendBtn" title="Share">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                                    </svg>
                                </button>
                                <button class="btn btn-danger btn-small" id="leaveBlendBtn">Leave</button>
                            </div>
                        </div>

                        <div class="now-playing-section" id="nowPlayingSection" style="display: none;">
                            <div class="section-label">Currently Playing</div>
                            <div class="now-playing-track">
                                <img class="now-playing-cover" id="nowPlayingCover" src="" alt="">
                                <div class="now-playing-info">
                                    <div class="now-playing-title" id="nowPlayingTitle"></div>
                                    <div class="now-playing-artist" id="nowPlayingArtist"></div>
                                </div>
                            </div>
                        </div>

                        <div class="queue-section-blend">
                            <div class="section-label">Coming Next</div>
                            <div id="comingNextList"></div>
                        </div>

                        <div class="blend-search-section">
                            <div class="section-label">Add Songs</div>
                            <div class="blend-search-bar">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                </svg>
                                <input type="text" class="blend-search-input" id="blendSearchInput"
                                    placeholder="Search for songs to add...">
                            </div>
                            <div class="blend-search-results" id="blendSearchResults"></div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div class="modal" id="joinBlendModal">
        <div class="modal-content">
            <div class="modal-header">Join Listen Together Session</div>
            <div class="form-group">
                <label class="form-label">Enter Blend ID or paste share link</label>
                <input type="text" class="form-input" id="joinBlendInput" placeholder="blend-123456 or full URL">
            </div>
            <div class="modal-buttons">
                <button class="btn btn-secondary" id="cancelJoinBlendBtn">Cancel</button>
                <button class="btn btn-primary" id="confirmJoinBlendBtn">Join</button>
            </div>
        </div>
    </div>

    <div class="player-bar">
        <div class="player-content">
            <div class="player-track">
                <div class="player-cover placeholder" id="playerCoverWrapper">
                    <img id="playerCover" src="" alt=""
                        style="display: none; width: 100%; height: 100%; object-fit: cover; border-radius: 4px;">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" id="placeholderIcon">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
                    </svg>
                </div>
                <div class="player-info">
                    <div class="player-title" id="playerTitle">No track selected</div>
                    <div class="player-artist" id="playerArtist">
                        Select a song to play
                        <span class="source-badge" id="sourceBadge" style="display: none;"></span>
                    </div>
                </div>
            </div>

            <div class="player-controls">
                <div class="controls-buttons">
                    <button class="control-button" id="prevBtn">
                        <svg fill="currentColor" viewBox="0 0 24 24">
                            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z" />
                        </svg>
                    </button>
                    <button class="control-button play-btn" id="playBtn">
                        <svg fill="currentColor" viewBox="0 0 24 24" id="playIcon">
                            <path d="M8 5v14l11-7z" />
                        </svg>
                        <svg fill="currentColor" viewBox="0 0 24 24" id="pauseIcon" style="display: none;">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                        </svg>
                    </button>
                    <button class="control-button" id="nextBtn">
                        <svg fill="currentColor" viewBox="0 0 24 24">
                            <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" />
                        </svg>
                    </button>
                </div>
                <div class="progress-wrapper">
                    <span class="time-label" id="currentTime">0:00</span>
                    <div class="progress-track" id="progressTrack">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                    <span class="time-label" id="totalTime">0:00</span>
                </div>
            </div>

            <div class="player-extra"></div>
        </div>
    </div>

    <audio id="audio" crossorigin="anonymous"></audio>

    <!-- Now playing overlay -->
    <div id="nowPlayingOverlay" aria-hidden="true">
        <div class="overlay-card" role="dialog" aria-modal="true">
            <button id="overlayClose" class="overlay-close" title="Close"></button>
            <img class="overlay-cover" id="overlayCover" src="/listenfreely.png" alt="Cover">
            <div class="overlay-info">
                <div class="overlay-title" id="overlayTitle">Title</div>
                <div class="overlay-artist" id="overlayArtist">Artist</div>
            </div>

            <div class="overlay-bottom">
                <div class="overlay-controls">
                    <button class="overlay-btn" id="overlayLike" title="Like/Unlike">
                        <svg id="overlayLikeIcon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 6 3.99 4 6.5 4 8.24 4 9.91 4.81 11 6.09 12.09 4.81 13.76 4 15.5 4 18.01 4 20 6 20 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6"/>
                        </svg>
                    </button>
                    <button class="overlay-btn" id="overlayPrev" title="Previous"></button>
                    <button class="overlay-btn" id="overlayPlay" title="Play/Pause"></button>
                    <button class="overlay-btn" id="overlayNext" title="Next"></button>
                    <button class="overlay-btn" id="overlayLoop" title="Loop"></button>
                </div>

                <div class="overlay-progress" id="overlayProgress" aria-label="Seek">
                    <div class="bar" id="overlayProgressBar"></div>
                </div>
                <div class="overlay-times"><span id="overlayCurrent">0:00</span><span id="overlayTotal">0:00</span></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.2/peerjs.min.js"></script>
    <script>
        const API_SOURCES = [
            {
                name: 'JioSaavn',
                displayName: 'JioSaavn',
                search: async (q) => {
                    const res = await fetch(`https://jiosaavn-api-privatecvc2.vercel.app/search/songs?query=${encodeURIComponent(q)}&page=1&limit=20`);
                    const data = await res.json();
                    return data.data.results.map(t => ({
                        id: t.id,
                        name: t.name,
                        artists: t.primaryArtists,
                        album: t.album?.name || 'Unknown',
                        cover: t.image?.[2]?.link || t.image?.[1]?.link || '',
                        duration: t.duration * 1000,
                        downloadUrl: t.downloadUrl?.[4]?.link || t.downloadUrl?.[3]?.link || t.downloadUrl?.[2]?.link,
                        source: 'JioSaavn'
                    }));
                },
                download: async (track) => track.downloadUrl
            }
        ];

        const state = {
            currentTrack: null,
            playlist: [],
            allTracks: [],
            currentIndex: -1,
            isPlaying: false,
            currentView: 'home',
            loopState: localStorage.getItem('loopState') || 'none',
            recentTracks: JSON.parse(localStorage.getItem('recentTracks') || '[]'),
            likedTracks: JSON.parse(localStorage.getItem('likedTracks') || '[]'),
            // offline tracking
            offlineTracks: [], // lightweight metadata list
            offlineUrlMap: {}, // id -> objectURL created for playback
            blend: {
                active: false,
                isHost: false,
                id: null,
                name: '',
                avatar: null,
                peers: new Map(),
                queue: [],
                participants: []
            }
        };

        // Daily most-played tracking (stored per-day in localStorage)
        function getTodayKey() {
            const d = new Date();
            return d.toISOString().slice(0,10); // YYYY-MM-DD
        }

        function loadDailyMostPlayed() {
            try {
                const key = 'dailyMostPlayed-' + getTodayKey();
                const raw = localStorage.getItem(key);
                state.mostPlayedDaily = raw ? JSON.parse(raw) : null;
            } catch (e) {
                console.warn('Could not load daily most played', e);
                state.mostPlayedDaily = null;
            }
        }

        function saveDailyMostPlayed(track) {
            try {
                const key = 'dailyMostPlayed-' + getTodayKey();
                localStorage.setItem(key, JSON.stringify(track));
                state.mostPlayedDaily = track;
            } catch (e) { console.warn('Could not save daily mostPlayed', e); }
        }

        function computeDailyMostPlayed() {
            try {
                const dateKey = getTodayKey();
                const countsKey = 'playCounts-' + dateKey;
                const metaKey = 'playCountsMeta-' + dateKey;
                const counts = JSON.parse(localStorage.getItem(countsKey) || '{}');
                const meta = JSON.parse(localStorage.getItem(metaKey) || '{}');
                let maxId = null, maxCount = 0;
                for (const id in counts) {
                    const c = counts[id] || 0;
                    if (c > maxCount) { maxCount = c; maxId = id; }
                }
                if (maxId && meta[maxId]) {
                    const t = Object.assign({}, meta[maxId]);
                    const yr = new Date().getFullYear();
                    t.subtitle = `Your most listened in ${yr}`;
                    saveDailyMostPlayed(t);
                }
            } catch (e) { console.warn('computeDailyMostPlayed failed', e); }
        }

        function incrementPlayCount(track) {
            try {
                const dateKey = getTodayKey();
                const countsKey = 'playCounts-' + dateKey;
                const metaKey = 'playCountsMeta-' + dateKey;
                const counts = JSON.parse(localStorage.getItem(countsKey) || '{}');
                const meta = JSON.parse(localStorage.getItem(metaKey) || '{}');
                const id = track.id || (track.downloadUrl || '') + '::' + (track.name || 'unknown');
                counts[id] = (counts[id] || 0) + 1;
                meta[id] = { id: id, name: track.name || 'Unknown', artists: track.artists || '', cover: track.cover || '', downloadUrl: track.downloadUrl || '' };
                localStorage.setItem(countsKey, JSON.stringify(counts));
                localStorage.setItem(metaKey, JSON.stringify(meta));
                // recompute winner and update UI
                computeDailyMostPlayed();
                // also update yearly aggregation for the current year so the "Most listened in YEAR" tile stays fresh
                try { computeYearlyMostPlayed(new Date().getFullYear()); } catch (e) {}
                try { renderExtraGrids(); } catch (e) {}
                try { renderHomeView(); } catch (e) {}
            } catch (e) { console.warn('incrementPlayCount failed', e); }
        }

        // load today's cached most-played at startup
        loadDailyMostPlayed();
        // load cached yearly most-played for current year
        try { loadYearlyMostPlayed(new Date().getFullYear()); } catch (e) {}
        // load liked-play aggregation (global most-loved)
        try { loadMostPlayedLiked(); } catch (e) {}

        // Whether the app is running as a PWA (standalone)  downloads only allowed in PWA mode
        function isPWA() {
            return window.matchMedia && window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;
        }

        // Download a track when running as a PWA. Uses the File System Access API if available,
        // otherwise falls back to a normal anchor download. If not running as a PWA, shows a prompt.
        async function downloadTrackPWA(track) {
            if (!isPWA()) {
                alert('Please install the app (add to home screen) to enable downloads.');
                return;
            }
            if (!track || !track.downloadUrl) { alert('No downloadable URL available for this track.'); return; }
            try {
                const res = await fetch(track.downloadUrl);
                if (!res.ok) throw new Error('Download failed');
                const blob = await res.blob();
                const sanitize = (s) => (s || 'track').replace(/[\\/:*?"<>|]/g, '_').slice(0, 120);
                const suggested = sanitize(track.name) + '.mp3';
                if (window.showSaveFilePicker) {
                    try {
                        const handle = await window.showSaveFilePicker({ suggestedName: suggested, types: [{ description: 'MP3', accept: { 'audio/mpeg': ['.mp3'] } }] });
                        const writable = await handle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        alert('Saved to device');
                        return;
                    } catch (e) {
                        // user cancelled or API failed  fall through to anchor fallback
                    }
                }
                // fallback: trigger a normal download (should work in many PWA contexts)
                const fileUrl = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = fileUrl;
                a.download = suggested;
                document.body.appendChild(a);
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(fileUrl), 5000);
            } catch (e) {
                console.error('downloadTrackPWA failed', e);
                alert('Download failed');
            }
        }

        // ---------- IndexedDB offline store (automatic saves & playback) ----------
        const OFFLINE_DB = 'ListenFreelyOffline';
        const OFFLINE_STORE = 'tracks';

        function openOfflineDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(OFFLINE_DB, 1);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(OFFLINE_STORE)) {
                        const s = db.createObjectStore(OFFLINE_STORE, { keyPath: 'id' });
                        s.createIndex('by-created', 'created', { unique: false });
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function initOfflineDB() {
            try {
                state.offlineDB = await openOfflineDB();
            } catch (e) {
                console.warn('Could not open offline DB', e);
                state.offlineDB = null;
            }
        }

        // Save track to offline store. Only proceeds when called with {userInitiated:true}
        async function saveTrackToOffline(track, opts = {}) {
            if (!opts.userInitiated) {
                console.warn('saveTrackToOffline called without userInitiated flag - ignoring to prevent unintended saves');
                console.trace();
                return;
            }
            if (!track) throw new Error('No track');
            await initOfflineDB();
            if (!state.offlineDB) throw new Error('Offline DB not available');
            const id = track.id || ((track.downloadUrl || '') + '::' + (track.name || 'unknown'));
            // fetch blob
            const res = await fetch(track.downloadUrl);
            if (!res.ok) throw new Error('Fetch failed');
            const blob = await res.blob();
            const rec = { id, name: track.name || '', artists: track.artists || '', cover: track.cover || '', blob, created: Date.now() };
            return new Promise((resolve, reject) => {
                const tx = state.offlineDB.transaction(OFFLINE_STORE, 'readwrite');
                const store = tx.objectStore(OFFLINE_STORE);
                const p = store.put(rec);
                p.onsuccess = () => {
                    loadOfflineIndex().then(() => resolve(rec)).catch(reject);
                };
                p.onerror = () => reject(p.error);
            });
        }

        async function removeOfflineTrack(id) {
            await initOfflineDB();
            if (!state.offlineDB) return;
            return new Promise((resolve, reject) => {
                const tx = state.offlineDB.transaction(OFFLINE_STORE, 'readwrite');
                const store = tx.objectStore(OFFLINE_STORE);
                const p = store.delete(id);
                p.onsuccess = () => {
                    // revoke any created object URL and stop playback if it was playing
                    try {
                        const url = state.offlineUrlMap[id];
                        if (url) {
                            try { URL.revokeObjectURL(url); } catch (e) {}
                            delete state.offlineUrlMap[id];
                            // if currently playing that url, stop and clear player
                            try {
                                if (el.audio && el.audio.src === url) {
                                    el.audio.pause();
                                    el.audio.src = '';
                                    state.isPlaying = false;
                                    el.playIcon.style.display = 'block';
                                    el.pauseIcon.style.display = 'none';
                                    el.playerTitle.textContent = 'No track selected';
                                    el.playerArtist.textContent = 'Select a song to play';
                                }
                            } catch (e) {}
                        }
                    } catch (e) {}
                    loadOfflineIndex().then(() => {
                        try { refreshDownloadButtons(); } catch (e) {}
                        resolve();
                    }).catch(reject);
                };
                p.onerror = () => reject(p.error);
            });
        }

        async function getOfflineTrackUrl(id) {
            await initOfflineDB();
            if (!state.offlineDB) return null;
            return new Promise((resolve, reject) => {
                const tx = state.offlineDB.transaction(OFFLINE_STORE, 'readonly');
                const store = tx.objectStore(OFFLINE_STORE);
                const p = store.get(id);
                p.onsuccess = () => {
                    const rec = p.result;
                    if (!rec || !rec.blob) return resolve(null);
                    // Reuse previously-created object URL if present to avoid leaks
                    if (state.offlineUrlMap[id]) {
                        resolve(state.offlineUrlMap[id]);
                        return;
                    }
                    const url = URL.createObjectURL(rec.blob);
                    state.offlineUrlMap[id] = url;
                    resolve(url);
                };
                p.onerror = () => reject(p.error);
            });
        }

        // Play an offline-saved track using the main player UI (updates state/currentTrack)
        async function playOfflineTrack(id) {
            if (!id) throw new Error('No id');
            const url = await getOfflineTrackUrl(id);
            if (!url) throw new Error('Offline file not found');

            const meta = (state.offlineTracks || []).find(r => r.id === id) || { id, name: 'Unknown', artists: '', cover: '' };

            // Set currentTrack to a lightweight object so the rest of the UI can use it
            state.currentTrack = { id: meta.id, name: meta.name, artists: meta.artists, cover: meta.cover, downloadUrl: url };
            state.playlist = [state.currentTrack];
            state.currentIndex = 0;

            // Update player cover/title/artist UI
            if (state.currentTrack.cover) {
                el.playerCover.src = state.currentTrack.cover;
                el.playerCover.style.display = 'block';
                el.placeholderIcon.style.display = 'none';
                el.playerCoverWrapper.classList.remove('placeholder');
            } else {
                el.playerCover.style.display = 'none';
                el.placeholderIcon.style.display = 'block';
                el.playerCoverWrapper.classList.add('placeholder');
            }
            el.playerTitle.textContent = state.currentTrack.name || 'Unknown';
            el.playerArtist.textContent = state.currentTrack.artists || '';

            try {
                el.audio.src = url;
                await el.audio.play();
                state.isPlaying = true;
                el.playIcon.style.display = 'none';
                el.pauseIcon.style.display = 'block';
                try { updatePlayerBarVisibility(); } catch (e) {}
                try { updateOverlayLikeButton(); } catch (e) {}
                // Add to recent so it shows up in Recents as a played item
                addToRecent(state.currentTrack);
            } catch (e) {
                throw e;
            }
        }

        async function isTrackOffline(id) {
            await initOfflineDB();
            if (!state.offlineDB) return false;
            return new Promise((resolve) => {
                const tx = state.offlineDB.transaction(OFFLINE_STORE, 'readonly');
                const store = tx.objectStore(OFFLINE_STORE);
                const p = store.getKey(id);
                p.onsuccess = () => resolve(!!p.result);
                p.onerror = () => resolve(false);
            });
        }

        async function loadOfflineIndex() {
            await initOfflineDB();
            if (!state.offlineDB) { state.offlineTracks = []; return; }
            return new Promise((resolve, reject) => {
                const tx = state.offlineDB.transaction(OFFLINE_STORE, 'readonly');
                const store = tx.objectStore(OFFLINE_STORE);
                const p = store.getAll();
                p.onsuccess = () => {
                    state.offlineTracks = (p.result || []).map(r => ({ id: r.id, name: r.name, artists: r.artists, cover: r.cover, created: r.created }));
                    try { if (state.currentView === 'downloads') renderDownloadsView(); } catch (e) {}
                    try { refreshDownloadButtons(); } catch (e) {}
                    resolve(state.offlineTracks);
                };
                p.onerror = () => reject(p.error);
            });
        }

        // Update all download button states across the UI to reflect offline index
        function refreshDownloadButtons() {
            const offlineIds = new Set((state.offlineTracks || []).map(r => r.id));
            document.querySelectorAll('.download-btn').forEach(btn => {
                const id = btn.dataset.id;
                const svg = btn.querySelector('svg');
                if (offlineIds.has(id)) {
                    btn.classList.add('downloaded');
                    if (svg) svg.setAttribute('fill', 'currentColor');
                } else {
                    btn.classList.remove('downloaded');
                    if (svg) svg.setAttribute('fill', 'none');
                }
            });
        }

        function renderDownloadsView() {
            const container = document.getElementById('downloadsList');
            if (!container) return;
            const tracks = state.offlineTracks || [];
            if (!tracks.length) {
                container.innerHTML = '<div class="empty-state"><p>No downloaded songs</p></div>';
                return;
            }
            container.innerHTML = tracks.map((t, i) => `
                <div class="track-card" data-id="${t.id}">
                    <img class="track-cover" src="${t.cover || generateMusicIconDataUrl()}">
                    <div class="track-details">
                        <div class="track-title">${t.name}</div>
                        <div class="track-subtitle">${t.artists}</div>
                    </div>
                    <div class="track-actions">
                        <button class="icon-btn play-offline-btn" data-id="${t.id}">Play</button>
                        <button class="icon-btn remove-offline-btn" data-id="${t.id}">Remove</button>
                    </div>
                </div>
            `).join('');

            container.querySelectorAll('.play-offline-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const id = btn.dataset.id;
                    try {
                        await playOfflineTrack(id);
                    } catch (err) { console.error(err); alert('Could not play offline file'); }
                });
            });

            container.querySelectorAll('.remove-offline-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const id = btn.dataset.id;
                    try {
                        await removeOfflineTrack(id);
                        renderDownloadsView();
                    } catch (err) { console.error(err); alert('Could not remove file'); }
                });
            });
        }

        // initialize offline DB index
        initOfflineDB().then(loadOfflineIndex).catch(e => console.warn('offline init failed', e));

        // Return a simple SVG music-note data URL used as a neutral fallback when no cover exists
        function generateMusicIconDataUrl() {
            const svg = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23bfbfbf' stroke-width='1.6'><path d='M9 19V6l10-3v13'/><circle cx='6' cy='18' r='2'/><circle cx='18' cy='16' r='2'/></svg>`;
            return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
        }

        function saveYearlyMostPlayed(track, year) {
            try {
                const key = 'yearlyMostPlayed-' + year;
                localStorage.setItem(key, JSON.stringify(track));
                state.mostPlayedYear = track;
            } catch (e) { console.warn('Could not save yearly mostPlayed', e); }
        }

        function loadYearlyMostPlayed(year) {
            try {
                const key = 'yearlyMostPlayed-' + year;
                const raw = localStorage.getItem(key);
                if (raw) state.mostPlayedYear = JSON.parse(raw);
                else computeYearlyMostPlayed(year);
            } catch (e) { console.warn('Could not load yearly most played', e); state.mostPlayedYear = null; }
        }

        function computeYearlyMostPlayed(year) {
            try {
                // iterate all per-day counts and aggregate those within the given year
                const prefix = 'playCounts-';
                const metaPrefix = 'playCountsMeta-';
                const totals = {};
                const metas = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (!key || !key.startsWith(prefix)) continue;
                    const datePart = key.slice(prefix.length); // YYYY-MM-DD
                    if (!datePart.startsWith(String(year))) continue;
                    const counts = JSON.parse(localStorage.getItem(key) || '{}');
                    const meta = JSON.parse(localStorage.getItem(metaPrefix + datePart) || '{}');
                    for (const id in counts) {
                        totals[id] = (totals[id] || 0) + (counts[id] || 0);
                        if (meta[id]) metas[id] = meta[id];
                    }
                }

                // exclude tracks that are already in the liked list
                const likedIds = new Set((state.likedTracks || []).map(t => t.id));
                let maxId = null, maxCount = 0;
                for (const id in totals) {
                    if (likedIds.has(id)) continue; // skip liked tracks
                    const c = totals[id] || 0;
                    if (c > maxCount) { maxCount = c; maxId = id; }
                }

                if (maxId && metas[maxId]) {
                    const t = Object.assign({}, metas[maxId]);
                    t.subtitle = `Your most listened in ${year}`;
                    saveYearlyMostPlayed(t, year);
                } else {
                    // no data for year
                    state.mostPlayedYear = null;
                }
            } catch (e) { console.warn('computeYearlyMostPlayed failed', e); }
        }

        // ---- liked-track global counting (no daily checks) ----
        function incrementLikedPlayCount(track) {
            try {
                if (!track || !track.id) return;
                if (!isLiked(track.id)) return; // only track plays for liked songs

                const key = 'likedPlayCounts';
                const metaKey = 'likedPlayMeta';
                const counts = JSON.parse(localStorage.getItem(key) || '{}');
                const meta = JSON.parse(localStorage.getItem(metaKey) || '{}');
                counts[track.id] = (counts[track.id] || 0) + 1;
                meta[track.id] = { id: track.id, name: track.name || 'Unknown', artists: track.artists || '', cover: track.cover || '', downloadUrl: track.downloadUrl || '' };
                localStorage.setItem(key, JSON.stringify(counts));
                localStorage.setItem(metaKey, JSON.stringify(meta));

                // recompute and update UI
                computeMostPlayedLiked();
                try { renderExtraGrids(); } catch (e) {}
            } catch (e) { console.warn('incrementLikedPlayCount failed', e); }
        }

        function computeMostPlayedLiked() {
            try {
                const key = 'likedPlayCounts';
                const metaKey = 'likedPlayMeta';
                const counts = JSON.parse(localStorage.getItem(key) || '{}');
                const meta = JSON.parse(localStorage.getItem(metaKey) || '{}');
                let maxId = null, maxCount = 0;
                // if there are explicit liked-play counts, use them
                for (const id in counts) {
                    const c = counts[id] || 0;
                    if (c > maxCount) { maxCount = c; maxId = id; }
                }

                // if none found, fall back to aggregating daily playCounts and picking the top among liked tracks
                if (!maxId || maxCount === 0) {
                    const prefix = 'playCounts-';
                    const agg = {};
                    for (let i = 0; i < localStorage.length; i++) {
                        const k = localStorage.key(i);
                        if (!k || !k.startsWith(prefix)) continue;
                        try {
                            const dayCounts = JSON.parse(localStorage.getItem(k) || '{}');
                            for (const id in dayCounts) agg[id] = (agg[id] || 0) + (dayCounts[id] || 0);
                        } catch (e) {}
                    }
                    // prefer only tracks that are in likedTracks
                    const likedIds = new Set((state.likedTracks || []).map(t => t.id));
                    for (const id in agg) {
                        if (likedIds.size > 0 && !likedIds.has(id)) continue;
                        const c = agg[id] || 0;
                        if (c > maxCount) { maxCount = c; maxId = id; }
                    }
                    // try to populate meta from daily meta keys if needed
                    if (maxId && !meta[maxId]) {
                        const metaPrefix = 'playCountsMeta-';
                        for (let i = 0; i < localStorage.length; i++) {
                            const k = localStorage.key(i);
                            if (!k || !k.startsWith(metaPrefix)) continue;
                            try {
                                const m = JSON.parse(localStorage.getItem(k) || '{}');
                                if (m[maxId]) { meta[maxId] = m[maxId]; break; }
                            } catch (e) {}
                        }
                    }
                }

                if (maxId && meta[maxId]) {
                    const t = Object.assign({}, meta[maxId]);
                    t.subtitle = 'Your most loved song';
                    state.mostPlayedLiked = t;
                } else {
                    state.mostPlayedLiked = null;
                }
            } catch (e) { console.warn('computeMostPlayedLiked failed', e); state.mostPlayedLiked = null; }
        }

        // Aggregate all playCounts (across all days) and return sorted list [{id,count,meta}]
        function getAllPlayCountsSorted() {
            try {
                const prefix = 'playCounts-';
                const metaPrefix = 'playCountsMeta-';
                const totals = {};
                const metas = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (!key || !key.startsWith(prefix)) continue;
                    const datePart = key.slice(prefix.length);
                    try {
                        const counts = JSON.parse(localStorage.getItem(key) || '{}');
                        const meta = JSON.parse(localStorage.getItem(metaPrefix + datePart) || '{}');
                        for (const id in counts) {
                            totals[id] = (totals[id] || 0) + (counts[id] || 0);
                            if (meta[id]) metas[id] = meta[id];
                        }
                    } catch (e) { }
                }
                const arr = Object.keys(totals).map(id => ({ id, count: totals[id], meta: metas[id] || null }));
                arr.sort((a, b) => b.count - a.count);
                return arr;
            } catch (e) { console.warn('getAllPlayCountsSorted failed', e); return []; }
        }

        // Pick the "second most repeated" track while skipping any IDs in excludeSet.
        // We will attempt to take the literal second item (index 1), but if it's excluded,
        // walk forward until we find a non-excluded item.
        function findSecondMostRepeatedExcluding(excludeSet) {
            try {
                const sorted = getAllPlayCountsSorted();
                if (!sorted || sorted.length === 0) return null;
                // prefer literal second-most (index 1), otherwise next non-excluded
                for (let i = 1; i < sorted.length; i++) {
                    const id = sorted[i].id;
                    if (excludeSet && excludeSet.has(id)) continue;
                    // return a minimal track object
                    const m = sorted[i].meta || {};
                    return { id: id, name: m.name || m.title || 'Unknown', artists: m.artists || '', cover: m.cover || '' };
                }
                // if no second found, try first (if not excluded)
                if (sorted.length > 0 && (!excludeSet || !excludeSet.has(sorted[0].id))) {
                    const m = sorted[0].meta || {};
                    return { id: sorted[0].id, name: m.name || m.title || 'Unknown', artists: m.artists || '', cover: m.cover || '' };
                }
                return null;
            } catch (e) { console.warn('findSecondMostRepeatedExcluding failed', e); return null; }
        }

        function loadMostPlayedLiked() {
            try {
                // ensure computation is done even if keys are missing
                computeMostPlayedLiked();
            } catch (e) { console.warn('loadMostPlayedLiked failed', e); state.mostPlayedLiked = null; }
        }

        let peer = null;

        const el = {
            searchInput: document.getElementById('searchInput'),
            searchResults: document.getElementById('searchResults'),
            recentTracks: document.getElementById('recentTracks'),
            likedTracks: document.getElementById('likedTracks'),
            audio: document.getElementById('audio'),
            playBtn: document.getElementById('playBtn'),
            playIcon: document.getElementById('playIcon'),
            pauseIcon: document.getElementById('pauseIcon'),
            prevBtn: document.getElementById('prevBtn'),
            nextBtn: document.getElementById('nextBtn'),
            progressBar: document.getElementById('progressBar'),
            progressTrack: document.getElementById('progressTrack'),
            currentTime: document.getElementById('currentTime'),
            totalTime: document.getElementById('totalTime'),
            playerCover: document.getElementById('playerCover'),
            playerCoverWrapper: document.getElementById('playerCoverWrapper'),
            placeholderIcon: document.getElementById('placeholderIcon'),
            playerTitle: document.getElementById('playerTitle'),
            playerArtist: document.getElementById('playerArtist'),
            sourceBadge: document.getElementById('sourceBadge'),
            createBlendBtn: document.getElementById('createBlendBtn'),
            joinBlendBtn: document.getElementById('joinBlendBtn'),
            leaveBlendBtn: document.getElementById('leaveBlendBtn'),
            blendInitial: document.getElementById('blendInitial'),
            blendActive: document.getElementById('blendActive'),
            blendAvatar: document.getElementById('blendAvatar'),
            blendAvatarInput: document.getElementById('blendAvatarInput'),
            blendNameDisplay: document.getElementById('blendNameDisplay'),
            editBlendNameBtn: document.getElementById('editBlendNameBtn'),
            participantCount: document.getElementById('participantCount'),
            shareBlendBtn: document.getElementById('shareBlendBtn'),
            nowPlayingSection: document.getElementById('nowPlayingSection'),
            nowPlayingCover: document.getElementById('nowPlayingCover'),
            nowPlayingTitle: document.getElementById('nowPlayingTitle'),
            nowPlayingArtist: document.getElementById('nowPlayingArtist'),
            comingNextList: document.getElementById('comingNextList'),
            blendSearchInput: document.getElementById('blendSearchInput'),
            blendSearchResults: document.getElementById('blendSearchResults'),
            joinBlendModal: document.getElementById('joinBlendModal'),
            joinBlendInput: document.getElementById('joinBlendInput'),
            confirmJoinBlendBtn: document.getElementById('confirmJoinBlendBtn'),
            cancelJoinBlendBtn: document.getElementById('cancelJoinBlendBtn')
            ,overlayLike: document.getElementById('overlayLike')
            ,overlayLikeIcon: document.getElementById('overlayLikeIcon')
        };

        // initialize audio.loop according to saved loop state
        try {
            if (el.audio) el.audio.loop = (state.loopState === 'one');
        } catch (e) {}

        // show/hide player bar depending on whether a track is selected
        function updatePlayerBarVisibility() {
            const pb = document.querySelector('.player-bar');
            if (!pb) return;
            if (state.currentTrack && (state.currentTrack.id || state.currentTrack.downloadUrl)) {
                pb.classList.remove('hidden');
            } else {
                pb.classList.add('hidden');
            }
        }

        function formatTime(s) {
            if (!s || isNaN(s)) return '0:00';
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m}:${sec.toString().padStart(2, '0')}`;
        }

        async function search(q) {
            if (!q.trim()) return;
            const results = {};
            state.allTracks = [];

            try {
                const saavnApi = API_SOURCES[0];
                const tracks = await saavnApi.search(q);
                if (tracks.length > 0) {
                    results[saavnApi.displayName] = tracks;
                    renderSearchResults(results);
                }
            } catch (e) {
                console.error('Search failed:', e);
            }
        }

        function renderSearchResults(results) {
            const sources = Object.keys(results);
            if (sources.length === 0) {
                el.searchResults.innerHTML = '<div class="empty-state"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/></svg><p>No results found</p></div>';
                return;
            }

            let html = '';
            sources.forEach(source => {
                const tracks = results[source];
                html += `
                    <div class="api-section">
                        <div class="api-header">
                            <span class="api-name">${source}</span>
                            <span class="api-count">${tracks.length} tracks</span>
                        </div>
                            <div class="tracks-grid">
                            ${tracks.map((t, i) => {
                                    const globalIndex = state.allTracks.length;
                                    state.allTracks.push(t);
                                    const offlineClass = (state.offlineTracks || []).some(r => r.id === t.id) ? 'downloaded' : '';
                                    return `
                                    <div class="track-card" data-index="${globalIndex}">
                                        <img class="track-cover" src="${t.cover}">
                                        <div class="track-details">
                                            <div class="track-title">${t.name}</div>
                                            <div class="track-subtitle">${t.artists}</div>
                                        </div>
                                        <div class="track-actions">
                                                            <button class="icon-btn download-btn ${offlineClass}" data-id="${t.id}" data-index="${globalIndex}" title="Download">
                                                                <svg fill="${offlineClass ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v12m0 0l4-4m-4 4l-4-4M21 21H3" />
                                                </svg>
                                            </button>
                                            <button class="icon-btn like-btn ${isLiked(t.id) ? 'active' : ''}" data-id="${t.id}">
                                                <svg fill="${isLiked(t.id) ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"/>
                                                </svg>
                                            </button>
                                            ${state.blend.active ?
                            `<button class="icon-btn" onclick="addToBlendQueue(${globalIndex})">
                                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                                                    </svg>
                                                </button>` : ''
                        }
                                        </div>
                                    </div>
                                `;
                }).join('')}
                        </div>
                    </div>
                `;
            });

            el.searchResults.innerHTML = html;
            state.playlist = state.allTracks;

            el.searchResults.querySelectorAll('.track-card').forEach(card => {
                card.addEventListener('click', e => {
                    if (!e.target.closest('.icon-btn')) {
                        playTrack(parseInt(card.dataset.index));
                    }
                });
            });

            el.searchResults.querySelectorAll('.like-btn').forEach(btn => {
                btn.addEventListener('click', e => {
                    e.stopPropagation();
                    toggleLike(btn.dataset.id);
                });
            });
            // download buttons (PWA-only)
            el.searchResults.querySelectorAll('.download-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const id = btn.dataset.id;
                    const idx = parseInt(btn.dataset.index);
                    let track = (state.playlist && state.playlist[idx]) || null;
                    if ((!track || !track.downloadUrl) && id) track = state.allTracks.find(t => t.id === id) || track;
                    if (!track) return;
                    try {
                        btn.classList.add('downloading');
                        await saveTrackToOffline(track, { userInitiated: true });
                        btn.classList.add('downloaded');
                        const svg = btn.querySelector('svg');
                        if (svg) svg.setAttribute('fill', 'currentColor');
                    } catch (err) {
                        console.error(err);
                        alert('Download failed');
                    } finally {
                        btn.classList.remove('downloading');
                    }
                });
            });
                
        }

        function renderTracks(tracks, container) {
            if (!tracks.length) {
                container.innerHTML = '<div class="empty-state"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/></svg><p>No tracks found</p></div>';
                return;
            }

            container.innerHTML = tracks.map((t, i) => {
                const offlineClass = (state.offlineTracks || []).some(r => r.id === t.id) ? 'downloaded' : '';
                return `
                <div class="track-card" data-index="${i}">
                    <img class="track-cover" src="${t.cover}">
                    <div class="track-details">
                        <div class="track-title">${t.name}</div>
                        <div class="track-subtitle">${t.artists}</div>
                    </div>
                    <div class="track-actions">
                        <button class="icon-btn download-btn ${offlineClass}" data-id="${t.id}" data-index="${i}" title="Download">
                            <svg fill="${offlineClass ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v12m0 0l4-4m-4 4l-4-4M21 21H3" />
                            </svg>
                        </button>
                        <button class="icon-btn like-btn ${isLiked(t.id) ? 'active' : ''}" data-id="${t.id}">
                            <svg fill="${isLiked(t.id) ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `}).join('');

            container.querySelectorAll('.track-card').forEach(card => {
                card.addEventListener('click', e => {
                    if (!e.target.closest('.icon-btn')) {
                        playTrack(parseInt(card.dataset.index));
                    }
                });
            });

            container.querySelectorAll('.like-btn').forEach(btn => {
                btn.addEventListener('click', e => {
                    e.stopPropagation();
                    toggleLike(btn.dataset.id);
                });
            });
            // download buttons (PWA-only download flow)
            container.querySelectorAll('.download-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const id = btn.dataset.id;
                    const idx = parseInt(btn.dataset.index);
                    let track = (state.playlist && state.playlist[idx]) || null;
                    if ((!track || !track.downloadUrl) && id) track = state.allTracks.find(t => t.id === id) || track;
                    if (!track) return;
                    try {
                        btn.classList.add('downloading');
                        await saveTrackToOffline(track, { userInitiated: true });
                        btn.classList.add('downloaded');
                        const svg = btn.querySelector('svg');
                        if (svg) svg.setAttribute('fill', 'currentColor');
                    } catch (err) {
                        console.error(err);
                        alert('Download failed');
                    } finally {
                        btn.classList.remove('downloading');
                    }
                });
            });
            
        }

        function isLiked(id) {
            return state.likedTracks.some(t => t.id === id);
        }

        function toggleLike(id) {
            const track = state.playlist.find(t => t.id === id);
            if (!track) return;

            const index = state.likedTracks.findIndex(t => t.id === id);
            if (index > -1) {
                state.likedTracks.splice(index, 1);
            } else {
                state.likedTracks.unshift(track);
            }
            localStorage.setItem('likedTracks', JSON.stringify(state.likedTracks));
            // Update UI across all lists immediately (search, recent, liked, blend)
            updateLikeButtons();

            if (state.currentView === 'search') {
                search(el.searchInput.value);
            } else if (state.currentView === 'liked') {
                renderTracks(state.likedTracks, el.likedTracks);
            } else if (state.currentView === 'recent') {
                renderTracks(state.recentTracks, el.recentTracks);
            } else if (state.currentView === 'blend') {
                // update blend-related lists if present
                updateQueueUI();
                if (el.blendSearchResults) {
                    // blend search results rendered separately - re-run small update
                    document.querySelectorAll('#blendSearchResults .like-btn').forEach(btn => {
                        const btnId = btn.dataset.id;
                        if (isLiked(btnId)) btn.classList.add('active'); else btn.classList.remove('active');
                    });
                }
            }
        }

        // Toggle like using a full track object (useful for overlay where currentTrack
        // may not be part of the current `state.playlist` array)
        function toggleLikeByTrack(track) {
            if (!track) return;
            const id = track.id || ((track.downloadUrl || '') + '::' + (track.name || 'unknown'));
            const index = state.likedTracks.findIndex(t => t.id === id);
            if (index > -1) {
                state.likedTracks.splice(index, 1);
            } else {
                // prefer storing a lightweight track object
                state.likedTracks.unshift({ id: id, name: track.name || track.title || 'Unknown', artists: track.artists || '', cover: track.cover || '', downloadUrl: track.downloadUrl || '' });
            }
            localStorage.setItem('likedTracks', JSON.stringify(state.likedTracks));
            updateLikeButtons();

            if (state.currentView === 'liked') {
                renderTracks(state.likedTracks, el.likedTracks);
            } else if (state.currentView === 'recent') {
                renderTracks(state.recentTracks, el.recentTracks);
            } else if (state.currentView === 'blend') {
                try { updateQueueUI(); } catch (e) {}
            }
        }

        // Update all like buttons across the UI to reflect current liked state
        function updateLikeButtons() {
            document.querySelectorAll('.like-btn').forEach(btn => {
                const id = btn.dataset.id;
                const svg = btn.querySelector('svg');
                if (isLiked(id)) {
                    btn.classList.add('active');
                    if (svg) svg.setAttribute('fill', 'currentColor');
                } else {
                    btn.classList.remove('active');
                    if (svg) svg.setAttribute('fill', 'none');
                }
            });
            // also update overlay like button if present
            try { updateOverlayLikeButton(); } catch (e) {}
        }

        function addToRecent(track) {
            state.recentTracks = [track, ...state.recentTracks.filter(t => t.id !== track.id)].slice(0, 50);
            localStorage.setItem('recentTracks', JSON.stringify(state.recentTracks));
        }

        function updateOverlayLikeButton() {
            const btn = el.overlayLike;
            const ico = el.overlayLikeIcon;
            if (!btn || !ico) return;
            const t = state.currentTrack;
            if (t && isLiked(t.id)) {
                btn.classList.add('active');
                btn.classList.add('like-active');
                ico.setAttribute('fill', 'currentColor');
                ico.setAttribute('stroke', 'none');
            } else {
                btn.classList.remove('active');
                btn.classList.remove('like-active');
                ico.setAttribute('fill', 'none');
                ico.setAttribute('stroke', 'currentColor');
            }
        }

        

        async function playTrack(index, skipBroadcast = false) {
            if (index < 0 || index >= state.playlist.length) return;

            state.currentIndex = index;
            state.currentTrack = state.playlist[index];

            try {
                let url = state.currentTrack.downloadUrl;
                el.audio.src = url;

                if (state.currentTrack.cover) {
                    el.playerCover.src = state.currentTrack.cover;
                    el.playerCover.style.display = 'block';
                    el.placeholderIcon.style.display = 'none';
                    el.playerCoverWrapper.classList.remove('placeholder');
                } else {
                    el.playerCover.style.display = 'none';
                    el.placeholderIcon.style.display = 'block';
                    el.playerCoverWrapper.classList.add('placeholder');
                }

                el.playerTitle.textContent = state.currentTrack.name;
                el.playerArtist.textContent = state.currentTrack.artists;

                if (state.currentTrack.source) {
                    el.sourceBadge.textContent = state.currentTrack.source;
                    el.sourceBadge.style.display = 'inline-block';
                } else {
                    el.sourceBadge.style.display = 'none';
                }

                await el.audio.play();
                state.isPlaying = true;
                el.playIcon.style.display = 'none';
                el.pauseIcon.style.display = 'block';

                // ensure the player bar is visible now that a track is selected/playing
                try { updatePlayerBarVisibility(); } catch (e) {}
                try { updateOverlayLikeButton(); } catch (e) {}

                addToRecent(state.currentTrack);
                try {
                    // increment today's play count for this track
                    if (state.currentTrack && state.currentTrack.id) {
                            incrementPlayCount(state.currentTrack);
                        // also increment liked-play counter (global)
                        try { incrementLikedPlayCount(state.currentTrack); } catch (e) {}
                    }
                } catch (e) { console.warn('incrementPlayCount failed', e); }

                    // (offline playback via IndexedDB removed)

                if (state.blend.active) {
                    updateQueueUI();
                    updateNowPlaying();
                    if (!skipBroadcast) {
                        broadcastToAll({
                            type: 'play-track',
                            index,
                            seek: 0
                        });
                    }
                }
            } catch (e) {
                console.error('Play failed:', e);
            }
        }

        async function playTrackSilent(index) {
            await playTrack(index, true);
        }

        el.playBtn.addEventListener('click', () => {
            if (state.isPlaying) {
                el.audio.pause();
                state.isPlaying = false;
                el.playIcon.style.display = 'block';
                el.pauseIcon.style.display = 'none';
                if (state.blend.active) {
                    if (state.blend.isHost) {
                        broadcastToAll({ type: 'play-pause', playing: false, time: el.audio.currentTime, timestamp: Date.now() });
                    } else {
                        // ask host to pause at this time
                        sendToHost({ type: 'play-toggle-request', playing: false, time: el.audio.currentTime, timestamp: Date.now(), currentIndex: state.currentIndex });
                    }
                }
            } else {
                el.audio.play();
                state.isPlaying = true;
                el.playIcon.style.display = 'none';
                el.pauseIcon.style.display = 'block';
                if (state.blend.active) {
                    if (state.blend.isHost) {
                        broadcastToAll({ type: 'play-pause', playing: true, time: el.audio.currentTime, timestamp: Date.now() });
                    } else {
                        // ask host to play this track/time
                        sendToHost({ type: 'play-toggle-request', playing: true, time: el.audio.currentTime, timestamp: Date.now(), currentIndex: state.currentIndex });
                    }
                }
            }
        });

        // overlay like button: toggle like for the currently playing track
        if (el.overlayLike) {
            el.overlayLike.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!state.currentTrack) return;
                try {
                    toggleLikeByTrack(state.currentTrack);
                    updateOverlayLikeButton();
                } catch (err) { console.warn('overlay like failed', err); }
            });
        }

        el.prevBtn.addEventListener('click', () => {
            if (state.currentIndex > 0) {
                playTrack(state.currentIndex - 1);
            }
        });

        el.nextBtn.addEventListener('click', () => {
            if (state.currentIndex < state.playlist.length - 1) {
                playTrack(state.currentIndex + 1);
            }
        });

        el.audio.addEventListener('timeupdate', () => {
            const p = (el.audio.currentTime / el.audio.duration) * 100;
            el.progressBar.style.width = `${p || 0}%`;
            el.currentTime.textContent = formatTime(el.audio.currentTime);
        });

        el.audio.addEventListener('loadedmetadata', () => {
            el.totalTime.textContent = formatTime(el.audio.duration);
        });

        el.audio.addEventListener('ended', () => {
            // handle loop modes: 'none' | 'all' | 'one'
            const loop = state.loopState || 'none';
            if (loop === 'one') {
                // audio.loop should handle this, but ensure playback continues
                // nothing to do here (browser will repeat current track)
                return;
            }

            // For 'all' mode, wrap to start when at end
            if (state.currentIndex < state.playlist.length - 1) {
                if (state.blend.active) {
                    if (state.blend.isHost) playTrack(state.currentIndex + 1);
                } else {
                    playTrack(state.currentIndex + 1);
                }
            } else {
                if (loop === 'all' && state.playlist.length > 0) {
                    // go to first track
                    if (state.blend.active) {
                        if (state.blend.isHost) playTrack(0);
                    } else {
                        playTrack(0);
                    }
                } else {
                    state.isPlaying = false;
                    el.playIcon.style.display = 'block';
                    el.pauseIcon.style.display = 'none';
                }
            }
        });

        let seekTimeout;
        el.progressTrack.addEventListener('click', e => {
            const rect = el.progressTrack.getBoundingClientRect();
            const p = (e.clientX - rect.left) / rect.width;
            const seekTime = p * el.audio.duration;
            el.audio.currentTime = seekTime;

            // Sync seek with peers
            if (state.blend.active) {
                clearTimeout(seekTimeout);
                seekTimeout = setTimeout(() => {
                    if (state.blend.isHost) {
                        broadcastToAll({ type: 'seek', time: seekTime, timestamp: Date.now() });
                    } else {
                        sendToHost({ type: 'seek-request', time: seekTime, timestamp: Date.now(), currentIndex: state.currentIndex });
                    }
                }, 100);
            }
        });

        // Home view helpers
        function computeGreeting() {
            const h = new Date().getHours();
            if (h >= 5 && h < 12) return 'Good morning';
            if (h >= 12 && h < 17) return 'Good afternoon';
            if (h >= 17 && h < 22) return 'Good evening';
            return 'Good night';
        }

        function renderHomeView() {
            const g = computeGreeting();
            const sub = (g === 'Good night') ? 'Take a rest  we saved your queue' : 'Welcome back  pick something to listen to';
            const elG = document.getElementById('homeGreeting');
            if (elG) elG.textContent = g;
            // populate bento thumbnails (simple, non-critical)
            const bento = document.getElementById('homeBento');
            if (bento) {
                const tiles = Array.from(bento.querySelectorAll('.bento-tile'));
                tiles.forEach(tile => {
                    const t = tile.dataset.target;
                    let img = '/listenfreely.png';
                    if (t === 'liked' && state.likedTracks && state.likedTracks[0]) img = state.likedTracks[0].cover || img;
                    if (t === 'recent' && state.recentTracks && state.recentTracks[0]) img = state.recentTracks[0].cover || img;
                    if (t === 'mostPlayed') {
                        // prefer yearly winner, then today's winner, then most-loved, then recent as fallback
                        const winner = state.mostPlayedYear || state.mostPlayedDaily || state.mostPlayedLiked || (state.recentTracks && state.recentTracks[0]) || (state.likedTracks && state.likedTracks[0]);
                        if (winner && winner.cover) img = winner.cover || img;
                    }
                    if (t === 'blend' && state.blend && state.blend.avatar) img = state.blend.avatar || img;
                    const imgEl = tile.querySelector('.bento-img');
                    if (imgEl) imgEl.src = img;
                    // attach click handlers: navigate or play directly for mostPlayed
                    tile.onclick = async () => {
                        if (t === 'liked') {
                            const nav = document.querySelector('.nav-item[data-view="liked"]'); if (nav) nav.click();
                        } else if (t === 'recent') {
                            const nav = document.querySelector('.nav-item[data-view="recent"]'); if (nav) nav.click();
                        } else if (t === 'blend') {
                            const nav = document.querySelector('.nav-item[data-view="blend"]'); if (nav) nav.click();
                        } else if (t === 'mostPlayed') {
                            // Play the computed most-played candidate: prefer yearly, then daily, then most-loved, else fallback
                            const winner = state.mostPlayedYear || state.mostPlayedDaily || state.mostPlayedLiked;
                            let candidate = null;
                            if (winner && winner.id) {
                                candidate = (state.allTracks || []).find(x => x.id === winner.id) || (state.recentTracks || []).find(x => x.id === winner.id) || (state.likedTracks || []).find(x => x.id === winner.id) || winner;
                            }
                            // final fallback to any recent/liked/all track
                            if (!candidate) candidate = (state.recentTracks && state.recentTracks[0]) || (state.likedTracks && state.likedTracks[0]) || (state.allTracks && state.allTracks[0]);
                            if (candidate) {
                                state.playlist = [candidate];
                                try { await playTrack(0); } catch (e) { console.warn('Failed to play mostPlayed', e); }
                            } else {
                                const nav = document.querySelector('.nav-item[data-view="search"]'); if (nav) nav.click();
                            }
                        } else {
                            const nav = document.querySelector('.nav-item[data-view="search"]'); if (nav) nav.click();
                        }
                    };
                });
                }
                // render imported extra grids
                try { renderExtraGrids(); } catch (e) {}
            }
        

        // Imported grids generator (from new.html)
        function renderExtraGrids() {
            const grid = document.getElementById('extraBentoGrid');
            if (!grid) return;
            grid.innerHTML = '';

            // Build items dynamically; the first (large) tile is today's most-played if available
            const year = new Date().getFullYear();
            const items = [];
            // prefer the yearly aggregated winner for the large tile; fall back to today's winner, then to a neutral placeholder
            if (state.mostPlayedYear && state.mostPlayedYear.id) {
                items.push({ title: state.mostPlayedYear.name || `Most listened in ${year}`, subtitle: state.mostPlayedYear.subtitle || `Your most listened in ${year}`, size: 'large', artist: state.mostPlayedYear.artists || '', cover: state.mostPlayedYear.cover, id: state.mostPlayedYear.id });
            } else if (state.mostPlayedDaily && state.mostPlayedDaily.id) {
                items.push({ title: state.mostPlayedDaily.name || 'Most Played', subtitle: state.mostPlayedDaily.subtitle || `Your most listened in ${year}`, size: 'large', artist: state.mostPlayedDaily.artists || '', cover: state.mostPlayedDaily.cover, id: state.mostPlayedDaily.id });
            } else {
                items.push({ title: `Most listened in ${year}`, subtitle: `No data for ${year}`, size: 'large' });
            }
            // fallback tiles: prefer most-played liked song, otherwise a neutral placeholder
            if (state.mostPlayedLiked && state.mostPlayedLiked.id) {
                items.push({ title: state.mostPlayedLiked.name || 'Most loved', subtitle: state.mostPlayedLiked.subtitle || 'Your most loved song', size: 'normal', artist: state.mostPlayedLiked.artists || '', cover: state.mostPlayedLiked.cover, id: state.mostPlayedLiked.id });
            } else {
                items.push({ title: 'Most loved', subtitle: '', size: 'normal' });
            }

            // third card: second-most-repeated track (must not be same as most-loved or the yearly most-played)
            const exclude = new Set();
            if (state.mostPlayedYear && state.mostPlayedYear.id) exclude.add(state.mostPlayedYear.id);
            if (state.mostPlayedDaily && state.mostPlayedDaily.id) exclude.add(state.mostPlayedDaily.id);
            if (state.mostPlayedLiked && state.mostPlayedLiked.id) exclude.add(state.mostPlayedLiked.id);
            const secondRepeated = findSecondMostRepeatedExcluding(exclude);
            if (secondRepeated) {
                items.push({ title: secondRepeated.name || 'Second Most', subtitle: 'You might wanna play', size: 'normal', artist: secondRepeated.artists || '', cover: secondRepeated.cover || '', id: secondRepeated.id });
            } else {
                items.push({ title: 'You might wanna play', subtitle: '', size: 'normal' });
            }


            function getCoverOrIcon(item) {
                if (item && item.cover) return item.cover;
                // For any extra-bento tile that lacks a cover, use the neutral music icon
                return generateMusicIconDataUrl();
            }

            items.forEach((item) => {
                const div = document.createElement('div');
                div.className = 'extra-bento-item ' + (item.size || '');

                const img = document.createElement('img');
                img.src = getCoverOrIcon(item);
                img.alt = item.title;

                const ov = document.createElement('div');
                ov.className = 'overlay';
                ov.innerHTML = `<div class="title">${item.title}</div><div class="subtitle">${item.subtitle}</div>`;

                div.appendChild(img);
                div.appendChild(ov);

                // click: if item represents a tracked song, attempt to play it; else navigate to search
                div.addEventListener('click', async () => {
                    if (item && item.id) {
                        // try to find full track object in state
                        let candidate = null;
                        try {
                            candidate = (state.allTracks || []).find(t => t.id === item.id) || (state.recentTracks || []).find(t => t.id === item.id) || (state.likedTracks || []).find(t => t.id === item.id) || item;
                        } catch (e) { candidate = item; }
                        if (candidate) {
                            state.playlist = [candidate];
                            try { await playTrack(0); } catch (e) { console.warn('Play from extra grid failed', e); }
                            return;
                        }
                    }
                    const nav = document.querySelector('.nav-item[data-view="search"]');
                    if (nav) nav.click();
                });

                grid.appendChild(div);
            });
        }

        let searchTimeout;
        el.searchInput.addEventListener('input', e => {
            clearTimeout(searchTimeout);
            const query = e.target.value.trim();
            if (query) {
                state.allTracks = [];
                searchTimeout = setTimeout(() => search(query), 500);
            } else {
                el.searchResults.innerHTML = '';
            }
        });

        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', () => {
                document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');

                const view = item.dataset.view;
                state.currentView = view;

                document.getElementById('homeView').style.display = view === 'home' ? 'block' : 'none';
                document.getElementById('searchView').style.display = view === 'search' ? 'block' : 'none';
                document.getElementById('recentView').style.display = view === 'recent' ? 'block' : 'none';
                document.getElementById('likedView').style.display = view === 'liked' ? 'block' : 'none';
                document.getElementById('downloadsView').style.display = view === 'downloads' ? 'block' : 'none';
                document.getElementById('blendView').style.display = view === 'blend' ? 'block' : 'none';

                if (view === 'recent') {
                    state.playlist = state.recentTracks;
                    renderTracks(state.recentTracks, el.recentTracks);
                } else if (view === 'liked') {
                    state.playlist = state.likedTracks;
                    renderTracks(state.likedTracks, el.likedTracks);
                } else if (view === 'blend') {
                    checkBlendUrl();
                } else if (view === 'downloads') {
                    try { renderDownloadsView(); } catch (e) {}
                } else if (view === 'home') {
                    // render greeting whenever user opens Home
                    try { renderHomeView(); } catch (e) {}
                }
            });
        });

        // Initialize view on load based on state.currentView
        (function initView() {
            // set active nav
            document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
            const nav = document.querySelector(`.nav-item[data-view="${state.currentView}"]`);
            if (nav) nav.classList.add('active');

            // show/hide views
            document.getElementById('homeView').style.display = state.currentView === 'home' ? 'block' : 'none';
            document.getElementById('searchView').style.display = state.currentView === 'search' ? 'block' : 'none';
            document.getElementById('recentView').style.display = state.currentView === 'recent' ? 'block' : 'none';
            document.getElementById('likedView').style.display = state.currentView === 'liked' ? 'block' : 'none';
            document.getElementById('downloadsView').style.display = state.currentView === 'downloads' ? 'block' : 'none';
            document.getElementById('blendView').style.display = state.currentView === 'blend' ? 'block' : 'none';

            try { if (state.currentView === 'home') renderHomeView(); } catch (e) {}
            try { if (state.currentView === 'downloads') renderDownloadsView(); } catch (e) {}
            try { updatePlayerBarVisibility(); } catch (e) {}
            try { updateOverlayLikeButton(); } catch (e) {}
            
        })();

        // WebRTC Blend
        function generateBlendId() {
            return 'blend-' + Math.random().toString(36).substr(2, 9);
        }

        function checkBlendUrl() {
            const params = new URLSearchParams(window.location.search);
            const blendId = params.get('blend');
            if (blendId && !state.blend.active) {
                el.joinBlendInput.value = blendId;
                el.joinBlendModal.classList.add('active');
            }
        }

        function createBlendSession() {
            const blendId = generateBlendId();
            state.blend.id = blendId;
            state.blend.isHost = true;
            state.blend.active = true;
            state.blend.participants = [{ id: 'host', name: 'You (Host)' }];
            state.blend.name = 'My Blend';

            window.history.pushState({}, '', `?blend=${blendId}`);

            el.blendInitial.style.display = 'none';
            el.blendActive.style.display = 'block';

            updateBlendUI();
            initializePeer(blendId);
            startHeartbeat();
        }

        function joinBlendSession(blendId) {
            state.blend.id = blendId;
            state.blend.isHost = false;
            state.blend.active = true;
            state.blend.participants = [{ id: 'peer', name: 'You' }];
            state.blend.name = 'Shared Blend';

            window.history.pushState({}, '', `?blend=${blendId}`);

            el.blendInitial.style.display = 'none';
            el.blendActive.style.display = 'block';

            updateBlendUI();
            connectToPeer(blendId);
            startHeartbeat();
        }

        function initializePeer(blendId) {
            const peerId = 'listenfreely-' + blendId;

            peer = new Peer(peerId, {
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });

            peer.on('open', (id) => {
                console.log('Session created:', id);
                updateParticipants();
            });

            peer.on('connection', (conn) => {
                console.log('Incoming connection');
                setupPeerConnection(conn);
            });

            peer.on('error', (error) => {
                console.error('Peer error:', error);
                if (error.type === 'unavailable-id') {
                    peer.destroy();
                    connectToPeer(blendId);
                }
            });
        }

        function connectToPeer(blendId) {
            const guestId = 'listenfreely-guest-' + Math.random().toString(36).substr(2, 9);

            peer = new Peer(guestId, {
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });

            peer.on('open', (id) => {
                console.log('Connected as guest:', id);

                const hostPeerId = 'listenfreely-' + blendId;
                setTimeout(() => {
                    const conn = peer.connect(hostPeerId);
                    setupPeerConnection(conn);
                }, 1000);
            });

            peer.on('connection', (conn) => {
                setupPeerConnection(conn);
            });
        }

        function setupPeerConnection(conn) {
            const peerInfo = {
                id: conn.peer,
                connection: conn,
                isConnected: false
            };

            conn.on('open', () => {
                console.log('Connection established');
                peerInfo.isConnected = true;
                state.blend.peers.set(conn.peer, peerInfo);

                state.blend.participants.push({
                    id: conn.peer,
                    name: state.blend.isHost ? 'Listener' : 'Host'
                });
                updateParticipants();

                // If host, broadcast updated participants to everyone
                if (state.blend.isHost) {
                    broadcastToAll({ type: 'participants-update', participants: state.blend.participants });
                }

                if (!state.blend.isHost) {
                    sendToPeer(conn, { type: 'sync-request' });
                }
            });

            conn.on('data', (data) => {
                handlePeerMessage(data, conn);
            });

            conn.on('close', () => {
                console.log('Connection closed');
                state.blend.peers.delete(conn.peer);
                state.blend.participants = state.blend.participants.filter(p => p.id !== conn.peer);
                updateParticipants();
            });
        }

        function handlePeerMessage(data, conn) {
            console.log('Received:', data);

            switch (data.type) {
                case 'heartbeat':
                    if (data.heartbeat) {
                        const hb = data.heartbeat;
                        // if this heartbeat comes from the host and we're a guest, request sync when out-of-sync
                        if (hb.isHost && !state.blend.isHost) {
                            const timeDiff = Math.abs((el.audio ? el.audio.currentTime : 0) - hb.currentTime);
                            const indexDiff = state.currentIndex !== hb.currentIndex;
                            const playingDiff = state.isPlaying !== hb.isPlaying;
                            if (timeDiff > 1 || indexDiff || playingDiff) {
                                // request authoritative state from host
                                sendToPeer(conn, { type: 'sync-request' });
                            }
                        }
                        // if we're host, we can monitor other peers' heartbeats (could add lastSeen tracking)
                    }
                    break;
                case 'sync-request':
                    if (state.blend.isHost) {
                        sendToPeer(conn, {
                            type: 'sync-response',
                            queue: state.blend.queue,
                            currentIndex: state.currentIndex,
                            currentTime: el.audio.currentTime,
                            isPlaying: state.isPlaying,
                            blendName: state.blend.name,
                            blendAvatar: state.blend.avatar
                        });
                    }
                    break;

                case 'play-toggle-request':
                    // only host should handle play requests
                    if (state.blend.isHost) {
                        const idx = typeof data.currentIndex === 'number' ? data.currentIndex : state.currentIndex;
                        if (idx !== state.currentIndex) {
                            playTrackSilent(idx);
                        }
                        // set time
                        try { if (typeof data.time === 'number') el.audio.currentTime = data.time; } catch (e) {}
                        if (data.playing) {
                            el.audio.play().catch(() => {});
                            state.isPlaying = true;
                        } else {
                            el.audio.pause();
                            state.isPlaying = false;
                        }
                        // broadcast authoritative state-update immediately
                        const st = { currentIndex: state.currentIndex, isPlaying: state.isPlaying, currentTime: el.audio.currentTime, queue: state.blend.queue, blendName: state.blend.name, blendAvatar: state.blend.avatar, participants: state.blend.participants, timestamp: Date.now() };
                        broadcastToAll({ type: 'state-update', state: st });
                    }
                    break;

                case 'seek-request':
                    if (state.blend.isHost && typeof data.time === 'number') {
                        try { el.audio.currentTime = data.time; } catch (e) {}
                        // broadcast authoritative seek
                        broadcastToAll({ type: 'seek', time: data.time, timestamp: Date.now() });
                    }
                    break;

                case 'sync-response':
                    state.blend.queue = data.queue || [];
                    state.playlist = state.blend.queue;

                    if (data.blendName) {
                        state.blend.name = data.blendName;
                        el.blendNameDisplay.textContent = data.blendName;
                    }
                    if (data.blendAvatar) {
                        state.blend.avatar = data.blendAvatar;
                        el.blendAvatar.innerHTML = `<img src="${data.blendAvatar}" alt="Avatar">`;
                    }

                    updateQueueUI();

                    if (data.queue && data.queue.length > 0 && data.currentIndex >= 0) {
                        playTrack(data.currentIndex);
                        setTimeout(() => {
                            el.audio.currentTime = data.currentTime || 0;
                            if (!data.isPlaying) {
                                el.audio.pause();
                                state.isPlaying = false;
                                el.playIcon.style.display = 'block';
                                el.pauseIcon.style.display = 'none';
                            }
                        }, 500);
                    }
                    break;

                case 'state-update':
                    if (data.state && !state.blend.isHost) {
                        const s = data.state;
                        state.blend.queue = s.queue || [];
                        state.playlist = state.blend.queue;
                        if (s.blendName) {
                            state.blend.name = s.blendName;
                            el.blendNameDisplay.textContent = s.blendName;
                        }
                        if (s.blendAvatar) {
                            state.blend.avatar = s.blendAvatar;
                            el.blendAvatar.innerHTML = `<img src="${s.blendAvatar}" alt="Avatar">`;
                        }
                        if (Array.isArray(s.participants)) {
                            state.blend.participants = s.participants;
                            updateParticipants();
                        }

                        updateQueueUI();

                        // Sync playback with host using timestamp compensation
                        const now = Date.now();
                        const latency = (now - (s.timestamp || now)) / 1000; // seconds
                        const targetTime = (s.currentTime || 0) + latency;

                        if (s.currentIndex !== undefined && s.currentIndex !== state.currentIndex) {
                            playTrack(s.currentIndex);
                        }

                        setTimeout(() => {
                            try {
                                el.audio.currentTime = Math.max(0, Math.min(el.audio.duration || Infinity, targetTime));
                            } catch (e) { }
                            if (s.isPlaying) {
                                el.audio.play().catch(() => { });
                                state.isPlaying = true;
                                el.playIcon.style.display = 'none';
                                el.pauseIcon.style.display = 'block';
                            } else {
                                el.audio.pause();
                                state.isPlaying = false;
                                el.playIcon.style.display = 'block';
                                el.pauseIcon.style.display = 'none';
                            }
                        }, 300);
                    }
                    break;

                case 'queue-add':
                    state.blend.queue.push(data.track);
                    state.playlist = state.blend.queue;
                    updateQueueUI();

                    // Only auto-play if host and no current track
                    if (state.blend.isHost && state.blend.queue.length === 1 && !state.currentTrack) {
                        setTimeout(() => {
                            playTrack(0);
                            broadcastToAll({
                                type: 'force-play',
                                index: 0,
                                timestamp: Date.now()
                            });
                        }, 300);
                    }
                    break;

                case 'play-track':
                    if (!state.isPlaying || state.currentIndex !== data.index) {
                        playTrackSilent(data.index);
                        if (data.seek !== undefined) {
                            setTimeout(() => {
                                el.audio.currentTime = data.seek;
                            }, 300);
                        }
                    }
                    break;

                case 'force-play':
                    // Force play from host, ignore local state
                    playTrackSilent(data.index);
                    break;

                case 'play-pause':
                    if (data.playing && !state.isPlaying) {
                        el.audio.play().catch(e => console.log('Play failed:', e));
                        state.isPlaying = true;
                        el.playIcon.style.display = 'none';
                        el.pauseIcon.style.display = 'block';
                    } else if (!data.playing && state.isPlaying) {
                        el.audio.pause();
                        state.isPlaying = false;
                        el.playIcon.style.display = 'block';
                        el.pauseIcon.style.display = 'none';
                    }
                    break;

                case 'seek':
                    if (Math.abs(el.audio.currentTime - data.time) > 1) {
                        el.audio.currentTime = data.time;
                    }
                    break;

                case 'blend-metadata-update':
                    if (data.name) {
                        state.blend.name = data.name;
                        el.blendNameDisplay.textContent = data.name;
                    }
                    if (data.avatar) {
                        state.blend.avatar = data.avatar;
                        el.blendAvatar.innerHTML = `<img src="${data.avatar}" alt="Avatar">`;
                    }
                    break;
                case 'participants-update':
                    if (Array.isArray(data.participants)) {
                        state.blend.participants = data.participants;
                        updateParticipants();
                    }
                    break;
                case 'queue-reorder':
                    if (Array.isArray(data.queue)) {
                        state.blend.queue = data.queue;
                        state.playlist = state.blend.queue;
                        updateQueueUI();
                    }
                    break;
                case 'queue-reorder-request':
                    // Only host should process requests to avoid conflicts
                    if (state.blend.isHost && typeof data.from === 'number' && typeof data.to === 'number') {
                        const fromIdx = data.from;
                        const toIdx = data.to;
                        if (fromIdx >= 0 && fromIdx < state.blend.queue.length && toIdx >= 0 && toIdx <= state.blend.queue.length) {
                            const tr = state.blend.queue.splice(fromIdx, 1)[0];
                            state.blend.queue.splice(toIdx, 0, tr);
                            // broadcast authoritative queue to all peers
                            broadcastToAll({ type: 'queue-reorder', queue: state.blend.queue });
                        }
                    }
                    break;
                case 'queue-remove-request':
                    if (state.blend.isHost && typeof data.index === 'number') {
                        const idx = data.index;
                        if (idx >= 0 && idx < state.blend.queue.length) {
                            state.blend.queue.splice(idx, 1);
                            state.playlist = state.blend.queue;
                            broadcastToAll({ type: 'queue-remove', index: idx });
                            updateQueueUI();
                        }
                    }
                    break;

                case 'queue-remove':
                    if (typeof data.index === 'number') {
                        const idx = data.index;
                        if (idx >= 0 && idx < state.blend.queue.length) {
                            state.blend.queue.splice(idx, 1);
                            state.playlist = state.blend.queue;
                            updateQueueUI();
                        }
                    }
                    break;
            }
        }

        function sendToPeer(conn, data) {
            if (conn && conn.open) {
                try {
                    conn.send(data);
                    console.log('Sent:', data.type);
                } catch (error) {
                    console.error('Error sending:', error);
                }
            }
        }

        function getHostConnection() {
            if (!state.blend || !state.blend.id) return null;
            const hostId = 'listenfreely-' + state.blend.id;
            // Try direct lookup first
            const direct = state.blend.peers.get(hostId);
            if (direct && direct.connection && direct.isConnected) return direct.connection;
            // Fallback: search peers map for a peer whose id matches hostId or appears to be the host
            for (const [key, info] of state.blend.peers.entries()) {
                if (!info || !info.connection) continue;
                if (info.id === hostId) return info.connection;
                // some peers may use different ids; treat the peer that registered as host as candidate
                if (key === hostId) return info.connection;
            }
            // Last resort: return the first connected peer (best-effort)
            for (const info of state.blend.peers.values()) {
                if (info && info.connection && info.isConnected) return info.connection;
            }
            return null;
        }

        function sendToHost(data) {
            const conn = getHostConnection();
            if (conn && conn.open) {
                sendToPeer(conn, data);
                return true;
            }
            // if host not found, try broadcasting as fallback
            try {
                broadcastToAll(data);
                return true;
            } catch (e) {
                console.warn('sendToHost fallback failed', e);
            }
            return false;
        }

        // Heartbeat: periodically broadcast local state to peers
        let heartbeatInterval = null;
        function startHeartbeat() {
            if (heartbeatInterval) return;
            heartbeatInterval = setInterval(() => {
                if (!state.blend.active) return;
                const timestamp = Date.now();
                if (state.blend.isHost) {
                    // host sends authoritative state updates periodically
                    const st = {
                        currentIndex: state.currentIndex,
                        isPlaying: !!state.isPlaying,
                        currentTime: el.audio ? el.audio.currentTime : 0,
                        queue: state.blend.queue,
                        blendName: state.blend.name,
                        blendAvatar: state.blend.avatar,
                        participants: state.blend.participants,
                        timestamp
                    };
                    broadcastToAll({ type: 'state-update', state: st });
                } else {
                    const hb = {
                        isHost: !!state.blend.isHost,
                        currentIndex: state.currentIndex,
                        isPlaying: !!state.isPlaying,
                        currentTime: el.audio ? el.audio.currentTime : 0,
                        queueLength: state.blend.queue.length,
                        blendName: state.blend.name,
                        blendAvatar: state.blend.avatar,
                        participants: state.blend.participants,
                        timestamp
                    };
                    broadcastToAll({ type: 'heartbeat', heartbeat: hb });
                }
            }, 2000);
        }

        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }

        function broadcastToAll(data) {
            console.log('Broadcasting:', data.type);
            state.blend.peers.forEach(peerInfo => {
                if (peerInfo.isConnected) {
                    sendToPeer(peerInfo.connection, data);
                }
            });
        }

        function updateParticipants() {
            const count = state.blend.participants.length;
            el.participantCount.textContent = `${count} listener${count !== 1 ? 's' : ''}`;
        }

        function leaveBlendSession() {
            state.blend.peers.forEach(peerInfo => {
                if (peerInfo.connection) {
                    try {
                        peerInfo.connection.close();
                    } catch (e) { }
                }
            });

            if (peer) {
                try {
                    peer.destroy();
                } catch (e) { }
                peer = null;
            }

            state.blend.active = false;
            state.blend.isHost = false;
            state.blend.id = null;
            state.blend.peers.clear();
            state.blend.queue = [];
            state.blend.participants = [];

            window.history.pushState({}, '', window.location.pathname);

            el.blendActive.style.display = 'none';
            el.blendInitial.style.display = 'block';
            stopHeartbeat();
        }

        function updateBlendUI() {
            el.blendNameDisplay.textContent = state.blend.name || 'My Blend';
            updateParticipants();
            updateQueueUI();
            updateNowPlaying();
            try { if (typeof updateLoopVisibility === 'function') updateLoopVisibility(); } catch (e) {}
        }

        function updateNowPlaying() {
            if (state.currentTrack) {
                el.nowPlayingSection.style.display = 'block';
                el.nowPlayingCover.src = state.currentTrack.cover || '';
                el.nowPlayingTitle.textContent = state.currentTrack.name;
                el.nowPlayingArtist.textContent = state.currentTrack.artists;
            } else {
                el.nowPlayingSection.style.display = 'none';
            }
        }

        function updateQueueUI() {
            const upcomingTracks = state.blend.queue.slice(state.currentIndex + 1);

            if (!upcomingTracks.length) {
                el.comingNextList.innerHTML = '<div class="empty-queue"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/></svg><p>No upcoming tracks</p></div>';
                return;
            }

            el.comingNextList.innerHTML = upcomingTracks.map((track, index) => {
                return `
                    <div class="queue-item-blend">
                        <div class="drag-handle">
                            <svg fill="currentColor" viewBox="0 0 24 24">
                                <path d="M9 3h2v2H9V3zm0 4h2v2H9V7zm0 4h2v2H9v-2zm0 4h2v2H9v-2zm0 4h2v2H9v-2zM13 3h2v2h-2V3zm0 4h2v2h-2V7zm0 4h2v2h-2v-2zm0 4h2v2h-2v-2zm0 4h2v2h-2v-2z"/>
                            </svg>
                        </div>
                        <button class="icon-btn remove-btn" title="Remove" data-id="${track.id}">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                        <img class="queue-item-cover" src="${track.cover}">
                        <div class="queue-item-info">
                            <div class="queue-item-title">${track.name}</div>
                            <div class="queue-item-artist">${track.artists}</div>
                        </div>
                    </div>
                `;
            }).join('');

            // Make queue items draggable and support reordering
            const parent = el.comingNextList;
            parent.querySelectorAll('.queue-item-blend').forEach((item, i) => {
                item.dataset.index = i;
                // enable HTML5 drag on desktop
                item.setAttribute('draggable', 'true');

                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', i);
                    item.classList.add('dragging');
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    // normalize indices after drag end
                    parent.querySelectorAll('.queue-item-blend').forEach((it, idx) => it.dataset.index = idx);
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const dragging = parent.querySelector('.dragging');
                    if (!dragging || dragging === item) return;
                    const from = parseInt(dragging.dataset.index, 10);
                    const to = parseInt(item.dataset.index, 10);
                    // visual re-order in DOM while dragging
                    if (from < to) parent.insertBefore(dragging, item.nextSibling);
                    else parent.insertBefore(dragging, item);
                    parent.querySelectorAll('.queue-item-blend').forEach((it, idx) => it.dataset.index = idx);
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const from = parseInt(e.dataTransfer.getData('text/plain'), 10);
                    const to = parseInt(item.dataset.index, 10);
                    if (isNaN(from) || isNaN(to) || from === to) return;
                    // identify the track id from the upcoming list (relative indices)
                    const upcoming = state.blend.queue.slice(state.currentIndex + 1);
                    const track = upcoming[from];
                    if (!track) return;

                    // optimistic local reorder in upcoming list
                    const absFrom = state.blend.queue.findIndex(t => t.id === track.id);
                    let absTo = state.currentIndex + 1 + to;
                    if (absFrom === -1) return;
                    // adjust absTo if removal before insertion changed indices
                    if (absFrom < absTo) absTo = Math.max(state.currentIndex + 1, absTo - 1);
                    state.blend.queue.splice(absFrom, 1);
                    state.blend.queue.splice(absTo, 0, track);
                    updateQueueUI();

                    if (state.blend.isHost) {
                        // host applies change and broadcasts authoritative queue
                        broadcastToAll({ type: 'queue-reorder', queue: state.blend.queue });
                    } else {
                        // non-host: request host to apply reorder by track id and relative target
                        sendToHost({ type: 'queue-reorder-request', id: track.id, to: to });
                    }
                });

                // wire up remove button
                const removeBtn = item.querySelector('.remove-btn');
                if (removeBtn) {
                    removeBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const relIndex = parseInt(item.dataset.index, 10);
                        const absIndex = relIndex + state.currentIndex + 1;
                        if (isNaN(absIndex)) return;
                        // If host, apply removal and broadcast; else request host to remove
                        if (state.blend.isHost) {
                            if (absIndex >= 0 && absIndex < state.blend.queue.length) {
                                state.blend.queue.splice(absIndex, 1);
                                state.playlist = state.blend.queue;
                                updateQueueUI();
                                broadcastToAll({ type: 'queue-remove', index: absIndex });
                            }
                        } else {
                            sendToHost({ type: 'queue-remove-request', index: absIndex, id: removeBtn.dataset.id });
                        }
                    });
                }
            });
        }

        window.addToBlendQueue = function (index) {
            if (!state.blend.active) return;

            const track = state.allTracks[index];
            console.log('Adding to queue:', track.name);

            state.blend.queue.push(track);
            state.playlist = state.blend.queue;
            updateQueueUI();

            const message = { type: 'queue-add', track };
            broadcastToAll(message);

            // Only host triggers auto-play
            if (state.blend.isHost && state.blend.queue.length === 1 && !state.currentTrack) {
                setTimeout(() => {
                    playTrack(0);
                }, 300);
            }
        };

        let blendSearchTimeout;
        el.blendSearchInput.addEventListener('input', (e) => {
            clearTimeout(blendSearchTimeout);
            const query = e.target.value.trim();
            if (query) {
                blendSearchTimeout = setTimeout(async () => {
                    try {
                        const saavnApi = API_SOURCES[0];
                        const tracks = await saavnApi.search(query);

                        el.blendSearchResults.innerHTML = tracks.slice(0, 5).map((t, i) => `
                            <div class="track-card" style="cursor: pointer;" onclick="addToBlendFromSearch(${i}, '${query}')">
                                <img class="track-cover" src="${t.cover}">
                                <div class="track-details">
                                    <div class="track-title">${t.name}</div>
                                    <div class="track-subtitle">${t.artists}</div>
                                </div>
                            </div>
                        `).join('');

                        window.blendSearchCache = tracks;
                    } catch (e) {
                        console.error('Search error:', e);
                    }
                }, 500);
            } else {
                el.blendSearchResults.innerHTML = '';
            }
        });

        window.addToBlendFromSearch = function (index, query) {
            const track = window.blendSearchCache[index];
            if (track) {
                state.blend.queue.push(track);
                state.playlist = state.blend.queue;
                updateQueueUI();

                broadcastToAll({ type: 'queue-add', track });

                el.blendSearchInput.value = '';
                el.blendSearchResults.innerHTML = '';

                // Only host triggers auto-play
                if (state.blend.isHost && state.blend.queue.length === 1 && !state.currentTrack) {
                    setTimeout(() => playTrack(0), 300);
                }
            }
        };

        el.blendAvatar.addEventListener('click', () => {
            el.blendAvatarInput.click();
        });

        el.blendAvatarInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    el.blendAvatar.innerHTML = `<img src="${event.target.result}" alt="Avatar">`;
                    state.blend.avatar = event.target.result;

                    // Broadcast avatar change
                    if (state.blend.active) {
                        broadcastToAll({
                            type: 'blend-metadata-update',
                            avatar: state.blend.avatar
                        });
                    }
                };
                reader.readAsDataURL(file);
            }
        });

        el.editBlendNameBtn.addEventListener('click', () => {
            const newName = prompt('Enter blend name:', state.blend.name);
            if (newName && newName.trim()) {
                state.blend.name = newName.trim();
                el.blendNameDisplay.textContent = state.blend.name;

                // Broadcast name change
                if (state.blend.active) {
                    broadcastToAll({
                        type: 'blend-metadata-update',
                        name: state.blend.name
                    });
                }
            }
        });

        el.shareBlendBtn.addEventListener('click', () => {
            const shareUrl = `${window.location.origin}${window.location.pathname}?blend=${state.blend.id}`;
            navigator.clipboard.writeText(shareUrl);

            const originalHTML = el.shareBlendBtn.innerHTML;
            el.shareBlendBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 18px; height: 18px;"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/></svg>';
            setTimeout(() => {
                el.shareBlendBtn.innerHTML = originalHTML;
            }, 2000);
        });

        el.createBlendBtn.addEventListener('click', createBlendSession);

        el.joinBlendBtn.addEventListener('click', () => {
            el.joinBlendModal.classList.add('active');
        });

        el.leaveBlendBtn.addEventListener('click', leaveBlendSession);

        el.confirmJoinBlendBtn.addEventListener('click', () => {
            let input = el.joinBlendInput.value.trim();
            if (input.includes('?blend=')) {
                input = input.split('?blend=')[1].split('&')[0];
            }
            if (input) {
                el.joinBlendModal.classList.remove('active');
                joinBlendSession(input);
            }
        });

        el.cancelJoinBlendBtn.addEventListener('click', () => {
            el.joinBlendModal.classList.remove('active');
        });

        checkBlendUrl();

        // Now-playing overlay: open when user taps the player title or cover
        (function () {
            const audio = document.getElementById('audio');
            const overlay = document.getElementById('nowPlayingOverlay');
            const overlayCover = document.getElementById('overlayCover');
            const overlayTitle = document.getElementById('overlayTitle');
            const overlayArtist = document.getElementById('overlayArtist');
            const overlayPlay = document.getElementById('overlayPlay');
            const overlayPrev = document.getElementById('overlayPrev');
            const overlayNext = document.getElementById('overlayNext');
            const overlayLoop = document.getElementById('overlayLoop');
            const overlayClose = document.getElementById('overlayClose');
            const overlayProgress = document.getElementById('overlayProgress');
            const overlayProgressBar = document.getElementById('overlayProgressBar');
            const overlayCurrent = document.getElementById('overlayCurrent');
            const overlayTotal = document.getElementById('overlayTotal');

            function formatTime(s) { s = Math.max(0, Math.floor(s||0)); return Math.floor(s/60)+':' + String(s%60).padStart(2,'0'); }

            // collect control SVGs from bottom player for consistent icons
            const bottomPrevSvg = document.querySelector('#prevBtn svg');
            const bottomNextSvg = document.querySelector('#nextBtn svg');
            const bottomPlayIcon = document.getElementById('playIcon');
            const bottomPauseIcon = document.getElementById('pauseIcon');

            function renderControlIcons() {
                try {
                    // prev
                    overlayPrev.innerHTML = '';
                    if (bottomPrevSvg) {
                        const clone = bottomPrevSvg.cloneNode(true);
                        clone.style.width = '22px';
                        clone.style.height = '22px';
                        overlayPrev.appendChild(clone);
                    } else {
                        overlayPrev.textContent = 'Prev';
                    }

                    // next
                    overlayNext.innerHTML = '';
                    if (bottomNextSvg) {
                        const clone = bottomNextSvg.cloneNode(true);
                        clone.style.width = '22px';
                        clone.style.height = '22px';
                        overlayNext.appendChild(clone);
                    } else {
                        overlayNext.textContent = 'Next';
                    }

                    // play/pause - choose based on audio state
                    overlayPlay.innerHTML = '';
                    const which = (audio && !audio.paused) ? bottomPauseIcon : bottomPlayIcon;
                    if (which) {
                        const clone = which.cloneNode(true);
                        clone.style.width = '26px';
                        clone.style.height = '26px';
                        overlayPlay.appendChild(clone);
                    } else {
                        overlayPlay.textContent = (audio && !audio.paused) ? 'Pause' : 'Play';
                    }
                    // loop icon (render separately)
                    try { renderLoopIcon(); } catch (e) {}
                } catch (err) {
                    // fallback
                }
            }

            function syncFromPlayer() {
                const pc = document.getElementById('playerCover');
                const pt = document.getElementById('playerTitle');
                const pa = document.getElementById('playerArtist');
                if (pc && pc.src) overlayCover.src = pc.src;
                if (pt) overlayTitle.textContent = pt.textContent.trim();
                if (pa) overlayArtist.textContent = pa.textContent.trim();
                overlayTotal.textContent = formatTime(audio.duration || 0);
                overlayCurrent.textContent = formatTime(audio.currentTime || 0);
                overlayProgressBar.style.width = ((audio.currentTime||0)/(audio.duration||1))*100 + '%';
                // update control icons
                renderControlIcons();
                // update loop icon & visibility
                try { updateLoopVisibility(); } catch (e) {}
            }

            // Loop control: none | all | one
            function getLoopState() {
                return state.loopState || (localStorage.getItem('loopState') || 'none');
            }

            function setLoopState(s) {
                state.loopState = s;
                localStorage.setItem('loopState', s);
                // audio.loop property controls single-track repeating
                if (audio) audio.loop = (s === 'one');
                renderLoopIcon();
            }

            function renderLoopIcon() {
                if (!overlayLoop) return;
                const s = getLoopState();
                overlayLoop.innerHTML = '';
                overlayLoop.style.opacity = (s === 'none') ? '0.85' : '1';
                // hide when in blend mode
                if (state.blend && state.blend.active) {
                    overlayLoop.style.display = 'none';
                    return;
                } else {
                    overlayLoop.style.display = 'flex';
                }

                if (s === 'all') {
                    // use provided repeat-every.svg (converted to currentColor and scaled)
                    overlayLoop.innerHTML = `
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M3.5 13L3.29592 12.0476C2.62895 8.93509 5.00172 6 8.18494 6H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M19 6L16 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M19 6L16 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M20.5 11L20.7041 11.9524C21.3711 15.0649 18.9983 18 15.8151 18H5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M5 18L8 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M5 18L8 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>`;
                } else if (s === 'one') {
                    // use provided loop-single.svg (converted stroke to currentColor)
                    overlayLoop.innerHTML = `
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M8 18H7C5.34315 18 4 16.6569 4 15V9C4 7.34315 5.34315 6 7 6H17C18.6569 6 20 7.34315 20 9V15C20 16.6569 18.6569 18 17 18H12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 18L15 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 18L15 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>`;
                } else {
                    // use provided no-repeat.svg (trimmed rect removed, scaled to 20)
                    overlayLoop.innerHTML = `
                        <svg viewBox="0 0 48 48" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M43.8233 25.2305C43.7019 25.9889 43.5195 26.727 43.2814 27.4395C42.763 28.9914 41.9801 30.4222 40.9863 31.6785C38.4222 34.9201 34.454 37 30 37H16C9.39697 37 4 31.6785 4 25C4 18.3502 9.39624 13 16 13L44 13" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M38 7L44 13L38 19" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>`;
                }
            }

            function updateLoopVisibility() {
                if (!overlayLoop) return;
                if (state.blend && state.blend.active) {
                    overlayLoop.style.display = 'none';
                } else {
                    overlayLoop.style.display = 'flex';
                }
            }

            if (overlayLoop) {
                overlayLoop.addEventListener('click', () => {
                    // cycle none -> all -> one -> none
                    const order = ['none','all','one'];
                    const cur = getLoopState();
                    const next = order[(order.indexOf(cur) + 1) % order.length];
                    setLoopState(next);
                });
                // initialise state
                try { setLoopState(getLoopState()); } catch (e) {}
            }

            // show overlay
            function openOverlay() {
                syncFromPlayer();
                overlay.classList.add('active');
                overlay.setAttribute('aria-hidden','false');
            }

            function closeOverlay() {
                overlay.classList.remove('active');
                overlay.setAttribute('aria-hidden','true');
            }

            // hook clicks on player title and cover
            const playerCoverWrapper = document.getElementById('playerCoverWrapper');
            const playerTitleEl = document.getElementById('playerTitle');
            if (playerCoverWrapper) playerCoverWrapper.addEventListener('click', openOverlay);
            if (playerTitleEl) playerTitleEl.addEventListener('click', openOverlay);

            // Click thumbnails across lists to play + open overlay
            document.addEventListener('click', async (ev) => {
                try {
                    const img = ev.target.closest && ev.target.closest('img.track-cover');
                    if (!img) return;
                    const card = img.closest('.track-card');
                    if (!card) return;
                    // prevent the card's own click handler from firing again
                    ev.stopPropagation();
                    const idx = card.dataset.index;
                    const id = card.dataset.id;
                    if (typeof idx !== 'undefined' && idx !== null && idx !== '') {
                        await playTrack(parseInt(idx));
                    } else if (id) {
                        // offline/downloaded item
                        await playOfflineTrack(id);
                    }
                    openOverlay();
                } catch (e) {
                    console.error('Thumbnail click play failed', e);
                }
            });

            // overlay close by clicking backdrop
            overlay.addEventListener('click', (e) => { if (e.target === overlay) closeOverlay(); });
            // close button
            if (overlayClose) overlayClose.addEventListener('click', closeOverlay);
            // close with Escape key
            document.addEventListener('keydown', (ev) => {
                if (ev.key === 'Escape' || ev.key === 'Esc') {
                    if (overlay && overlay.classList.contains('active')) closeOverlay();
                }
            });

            // play/pause
            overlayPlay.addEventListener('click', () => {
                if (typeof el !== 'undefined' && el.playBtn) {
                    el.playBtn.click();
                } else if (audio) {
                    if (audio.paused) audio.play(); else audio.pause();
                }
                setTimeout(syncFromPlayer, 50);
            });

            // prev/next
            overlayPrev.addEventListener('click', () => { if (typeof el !== 'undefined' && el.prevBtn) el.prevBtn.click(); });
            overlayNext.addEventListener('click', () => { if (typeof el !== 'undefined' && el.nextBtn) el.nextBtn.click(); });

            // seek bar interaction
            function seekFromEvent(e) {
                const r = overlayProgress.getBoundingClientRect();
                const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
                const p = Math.max(0, Math.min(1, x / r.width));
                if (audio && isFinite(audio.duration) && audio.duration > 0) audio.currentTime = p * audio.duration;
                syncFromPlayer();
            }
            overlayProgress.addEventListener('click', seekFromEvent);
            overlayProgress.addEventListener('touchstart', (e)=>{ seekFromEvent(e); }, {passive:true});

            // sync overlay while audio plays
            if (audio) {
                audio.addEventListener('timeupdate', syncFromPlayer);
                audio.addEventListener('loadedmetadata', syncFromPlayer);
                audio.addEventListener('play', syncFromPlayer);
                audio.addEventListener('pause', syncFromPlayer);
            }
        })();
    </script>
</body>

</html>